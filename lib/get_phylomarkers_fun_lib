#: VERSION: 2024-04-06
#: LIBRARY: get_phylomarkers_fun_lib
#     * functions called by run_get_phylomarkers_pipeline.sh
#     * part of the GET_PHYLOMARKERS software package
#
#: AUTHORS: Pablo Vinuesa, Center for Genomic Sciences, UNAM, Mexico
#           http://www.ccg.unam.mx/~vinuesa/ @pvinmex
#           Bruno Contreras Moreira, EEAD-CSIC, Zaragoza, Spain
#           https://digital.csic.es/cris/rp/rp02661/
#
#: DISCLAIMER: programs of the GET_PHYLOMARKERS package are distributed in the hope that it will be useful, 
#              but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
#              See the GNU General Public License for more details. 
#
#: LICENSE: This software is freely available under the GNU GENERAL PUBLIC LICENSE v.3.0
#           see https://github.com/vinuesa/get_phylomarkers/blob/master/LICENSE
#
#: AVAILABILITY: freely available from GitHub @ https://github.com/vinuesa/get_phylomarkers
#                freely available from DockerHub @ https://hub.docker.com/r/vinuesa/get_phylomarkers
#                                           and  @ https://hub.docker.com/r/csicunam/get_homologues
#
#: CITATION:
#  Pablo Vinuesa*, Luz Edith Ochoa-Sï¿½nchez and Bruno Contreras-Moreira (2018). 
#  GET_PHYLOMARKERS, a software package to select optimal orthologous clusters for phylogenomics 
#  and inferring pan-genome phylogenies, used for a critical geno-taxonomic revision of the genus Stenotrophomonas. 
#  Front. Microbiol. 9:771 | doi: 10.3389/fmicb.2018.00771. | PubMed PMID: 29765358 
#  Software code freely available on GitHub: https://github.com/vinuesa/get_phylomarkers


#---------------------------------------------------------------------------------#
#>>>>>>>>>>>>>>>>>>>>>>>>>>>> FUNCTION DEFINITIONS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<#
#---------------------------------------------------------------------------------#

function get_script_PID()
{
   #(( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   # returns the PID of the script, run by USER
   local prog user
   user=$1
   prog=${2%.*} # remove the script's .extension_name
   #proc_ID=$(ps -eaf|grep "$prog"|grep -v grep|grep '-'|grep $USER|awk '{print $2}')
   #proc_ID=$(ps aux|grep "$prog"|grep -v grep|grep '-'|grep $USER|awk '{print $2}')
   proc_ID=$(pgrep -u "$user" "$prog")
   echo "$proc_ID"
   #(( DEBUG > 0 )) && msg "$progname PID is: $proc_ID" DEBUG NC
}
#-----------------------------------------------------------------------------------------

function install_Rlibs_msg()
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local outfile Rpackage distrodir
   outfile=$1
   Rpackage=$2

   msg " ERROR: the expected outfile $outfile was not produced
            This may be because R package(s) $Rpackage are not properly installed.
            Please run the script './install_R_deps.R' from within \$distrodir to install them.
            Further installation tips can be found in file Rscript install_R_deps.R" ERROR RED

   R --no-save --quiet <<RCMD 2> /dev/null

       print("Your R installation currently searches for packages in :")
       print(.libPaths())
RCMD

# exit 0
   return 0
}
#-----------------------------------------------------------------------------------------

function count_tree_labels()
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   # call R pacake 'ape' to count the number of labels in a tree
   local ext outfile   
   ext=$1
   outfile=$2

   R --no-save --quiet <<RCMD

   pkg <- c("ape")

   local_lib <- c("${distrodir}/lib/R")
   distrodir <-c("$distrodir")

   .libPaths( c( .libPaths(), "${distrodir}/lib/R") )

   library("ape")

   if (!require(pkg, character.only=T, quietly=T)) {
       sprintf("# cannot load %s. Install it in %s using the command 'Rscript install_R_deps.R' from within %s",package,local_lib,distrodir)
       print("Your R installation currently searches for packages in :\n")
       print(.libPaths())
   }

   trees <- list.files(pattern = "$ext\$")
   sink("$outfile")

   for( i in 1:length(trees)){
      tr <- read.tree(trees[i])
      labels <- tr\$tip.label
      no_labels <- length(labels)
      cat(trees[i], "\t", no_labels, "\n")
   }
   sink()
RCMD

   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
}
#-----------------------------------------------------------------------------------------

function count_tree_branches()
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local ext outfile   
   ext=$1
   outfile=$2

   (( DEBUG > 0 )) && echo "# running count_tree_branches $ext $outfile"

   R --no-save --quiet <<RCMD &> /dev/null

   local_lib <- c("${distrodir}/lib/R")
   distrodir <- c("$distrodir")

   .libPaths( c(.libPaths(), local_lib) )
   required_packages <- c("ape")

   for (pkg in required_packages) {
     if (!require("ape", character.only=T, quietly=T)) {
       sprintf("# cannot load %s. Install it in %s using the command 'Rscript install_R_deps.R' from within %s",package,local_lib,distrodir)
       print("Your R installation currently searches for packages in :\n")
       print(.libPaths())
     }
   }
   library("ape")

   trees <- list.files(pattern = "$ext\$")
   sink("$outfile")
   cat("#Tree","\t", "n_leaf_lab", "\t", "n_zero_len_br" , "\t", "n_nodes", "\t", "n_br", "\t", "n_int_br", "\t", "n_ext_br", "\t", "is_binary_tree", "\n")

   no_int_br_counter <- 0

   for( i in 1:length(trees)){
      tr <- read.tree(trees[i])
      is_binary_tree <- is.binary.tree(tr)
      #no_branches <- length(tr\$edge.length) # equivalent to the line below
      no_branches <- dim(tr\$edge)[1]

      # we need to count the number of branches with lenght == 0
      # to remove those from the total count of no_branches computed above
      n_zero_length_branches <- length(which(tr\$edge.length == 0))

      # this is the real num. of branches on our tree
      no_branches <- no_branches - n_zero_length_branches

      Nnodes <- tr\$Nnode  # these are the internal nodes
      Ntips <- length(tr\$tip.label) # this is the number of tree labels or taxa

      # this is the number of nodes in a binary tree for n taxa/tip.label
      branches_in_binary_tree <- (2*Ntips - 3)
      #int_branches_in_binary_tree <- branches_in_binary_tree - Ntips

      # Using the eq. above, we can now estimate the real num. of ext branches
      # taking into account the real num of branches, after removing those with zelo length
      no_ext_branches <- floor((no_branches + 3) / 2) # floor() in case there is no real internal branch, we get -0.5
      no_int_branches <- ceiling(no_branches - no_ext_branches) # ceiling() in case there is no real internal branch, we get -0.5
      if ( no_int_branches < 1 ) no_int_br_counter <- no_int_br_counter + 1
      cat(trees[i], "\t", Ntips, "\t", n_zero_length_branches, "\t", Nnodes, "\t", no_branches, "\t", no_int_branches, "\t", no_ext_branches, "\t", is_binary_tree, "\n")
    }
   sink()

   # return this number from function to print in main script
   cat(no_int_br_counter)

RCMD

   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------
function estimate_FT_gene_trees()
{
   # estimate gene trees running FT in parallel using the user-defined thoroughness
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
    (( DEBUG > 0 )) && caller 0
    local mol_type search_thoroughness cmd fext basemod n_cores spr spr_length bindir
    
    mol_type=$1
    search_thoroughness=$2
    n_cores=$3
    spr=$4
    spr_length=$5
    bindir=$6
    
    cmd=''
    fext=''
    basemod=''
    
    
   if [ "$mol_type" == "DNA" ]
   then
       [ "$search_thoroughness" == "high" ] && FTmod="-quiet -nt -gtr -gamma -bionj -slow -slownni -mlacc 3 -spr $spr -sprlength $spr_length"
       [ "$search_thoroughness" == "medium" ] && FTmod="-quiet -nt -gtr -gamma -bionj -slownni -mlacc 3 -spr $spr -sprlength $spr_length"
       [ "$search_thoroughness" == "low" ] && FTmod="-quiet -nt -gtr -gamma -bionj -mlacc 2 -spr $spr -sprlength $spr_length"
       [ "$search_thoroughness" == "lowest" ] && FTmod="-quiet -nt -gtr -gamma -bionj"
       fext="fasta"
       basemod="GTR"
       cmd="${distrodir}/run_parallel_cmmds.pl $fext '${bindir}/FastTree $FTmod -log \${file%.*}.log < \$file > \${file%.*}_FT${basemod}.ph' $n_cores"
   else
       [ "$search_thoroughness" == "high" ] && FTmod="-quiet -lg -gamma -bionj -slow -slownni -mlacc 3 -spr $spr -sprlength $spr_length"
       [ "$search_thoroughness" == "medium" ] && FTmod="-quiet -lg -gamma -bionj -slownni -mlacc 3 -spr $spr -sprlength $spr_length"
       [ "$search_thoroughness" == "low" ] && FTmod="-quiet -lg -gamma -bionj -mlacc 2 -spr $spr -sprlength $spr_length"
       [ "$search_thoroughness" == "lowest" ] && FTmod="-quiet -lg -gamma -bionj"
       fext="faaln"
       basemod="lg"
       cmd="${distrodir}/run_parallel_cmmds.pl $fext '${bindir}/FastTree $FTmod -log \${file%.*}.log < \$file > \${file%.*}_FT${basemod}.ph' $n_cores"
   fi

   # NOTE: to execute run_parallel_cmmds.pl with a customized command, resulting from the interpolation of multiple varialbles,
   #	     we have first to save the command line in a variable and pipe its content into bash for execution.
   #       Then we can execute run_parallel_cmmds.pl with a customized command, interpolating of multiple varialbles
   #       Note the  && return 0 ; } to satisfy set -e strictness.
   (( DEBUG > 0 )) && msg "$cmd" DEBUG NC
   { echo "$cmd" | bash &> /dev/null && return 0 ; }
       
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

function compute_FT_gene_tree_stats()
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local mol_type search_thoroughness parent_PID i N
   mol_type=$1
   search_thoroughness=$2
   parent_PID=$3
   
      
   if [ "$mol_type" == "DNA" ]
   then
       s_type="FTdnaT${search_thoroughness}"

       # parse computation-times and lnL stats for FT-computed gene trees and write to table
       grep '^Gamma20LogLk' ./*.log | cut -f1,2 | sed 's/:Gamma20LogLk//; s/ /\t/' > "FT_lnL_cdnAln_FTGTRG_T${search_thoroughness}.tsv"
       grep '^Total time:' ./*.log | cut -d' ' -f3 > "FT_tot_wc_seconds_cdnAln_FTGTRG_T${search_thoroughness}.tsv"
       
       N=$(find . -name "*.log" | wc -l)
       
       i=0
       for (( i=1; i<=N; i++ )); do
            echo "$s_type" >> s_type.txt
       done
       
       echo -e "alignment\tlnL\twc_secs\s_type" > FT_gene_tree_stats.header
   
      if [ -s "FT_lnL_cdnAln_FTGTRG_T${search_thoroughness}.tsv" ] && [ -s "FT_tot_wc_seconds_cdnAln_FTGTRG_T${search_thoroughness}.tsv" ] && [ -s s_type.txt ]
      then
         # paste src files into table
	      paste "FT_lnL_cdnAln_FTGTRG_T${search_thoroughness}.tsv" "FT_tot_wc_seconds_cdnAln_FTGTRG_T${search_thoroughness}.tsv" s_type.txt > \
	      "FT_${mol_type}_gene_tree_T${search_thoroughness}_search_stats.tsv"
	      check_output "FT_${mol_type}_gene_tree_T${search_thoroughness}_search_stats.tsv" "$parent_PID"
        
	      # add header
	      cat "FT_gene_tree_stats.header" "FT_${mol_type}_gene_tree_T${search_thoroughness}_search_stats.tsv" > t && \
	      mv t "FT_${mol_type}_gene_tree_T${search_thoroughness}_search_stats.tsv"
	
	      # cleanup
	      rm FT_gene_tree_stats.header "FT_lnL_cdnAln_FTGTRG_T${search_thoroughness}.tsv" "FT_tot_wc_seconds_cdnAln_FTGTRG_T${search_thoroughness}.tsv" s_type.txt
      fi
   else
      s_type="FTprotT${search_thoroughness}"

      # parse computation-times and lnL stats for FT-computed gene trees and write to table
      grep '^Gamma20LogLk' ./*cluo.log | cut -f1,2 | sed 's/:Gamma20LogLk//; s/ /\t/' > "FT_lnL_protAln_FTlgG_T${search_thoroughness}.tsv"
      grep '^Total time:' ./*cluo.log | cut -d' ' -f3 > "FT_tot_wc_seconds_protAln_FTlgG_T${search_thoroughness}.tsv"
      
      N=$(find . -name "*.log" | wc -l)
      
      i=0
      for (( i=1; i<=N; i++ )); do
         echo "$s_type" >> s_type.txt
      done
      
      echo -e "alignment\tlnL\twc_secs\ts_type" > FT_gene_tree_stats.header
   
      if [ -s "FT_lnL_protAln_FTlgG_T${search_thoroughness}.tsv" ] && [ -s "FT_tot_wc_seconds_protAln_FTlgG_T${search_thoroughness}.tsv" ] && [ -s s_type.txt ]
      then
         # paste src files into table
	      paste "FT_lnL_protAln_FTlgG_T${search_thoroughness}.tsv" "FT_tot_wc_seconds_protAln_FTlgG_T${search_thoroughness}.tsv" s_type.txt > \
	      "FT_${mol_type}_gene_tree_T${search_thoroughness}_search_stats.tsv"
	      check_output "FT_${mol_type}_gene_tree_T${search_thoroughness}_search_stats.tsv" "$parent_PID"
       
	      # add header
	      cat FT_gene_tree_stats.header "FT_${mol_type}_gene_tree_T${search_thoroughness}_search_stats.tsv" > k && mv k "FT_${mol_type}_gene_tree_T${search_thoroughness}_search_stats.tsv"
	
	      # cleanup
	      rm FT_gene_tree_stats.header "FT_lnL_protAln_FTlgG_T${search_thoroughness}.tsv" "FT_tot_wc_seconds_protAln_FTlgG_T${search_thoroughness}.tsv" s_type.txt
      fi
   fi   
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

estimate_IQT_gene_trees()
{
   # estimate gene trees running IQT in parallel using the user-defined mset
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local cmd fext mol_type search_thoroughness
   mol_type=$1
   search_thoroughness=$2
   #IQT_models=$3

   if [ "$mol_type" == "DNA" ]
   then
       [ "$search_thoroughness" == "high" ] && IQTmod="-s \$file -st $mol_type -m MFP -T 1 -alrt 1000 -fast"
       [ "$search_thoroughness" == "medium" ] && IQTmod="-s \$file -st $mol_type -mset K2P,HKY,TN,TNe,TIM,TIMe,TIM2,TIM2e,TIM3,TIM3e,TVM,TVMe,GTR -m MFP -T 1 -alrt 1000 -fast"
       [ "$search_thoroughness" == "low" ] && IQTmod="-s \$file -st $mol_type -mset K2P,HKY,TN,TNe,TVM,TVMe,TIM,TIMe,GTR -m MFP -T 1 -alrt 1000 -fast"
       [ "$search_thoroughness" == "lowest" ] && IQTmod="-s \$file -st $mol_type -mset K2P,HKY,TN,TNe,TVM,TIM,GTR -m MFP -T 1 -alrt 1000 -fast"
       fext="fasta"
       cmd="${distrodir}/run_parallel_cmmds.pl $fext '${bindir}/iqtree $IQTmod'"
       (( DEBUG > 0 )) && msg "DNA IQT_gene_trees command: $cmd" DEBUG NC
   else
       [ "$search_thoroughness" == "high" ] && IQTmod="-s \$file -st $mol_type -m MFP -T 1 -alrt 1000 -fast"
       [ "$search_thoroughness" == "medium" ] && IQTmod="-s \$file -st $mol_type -mset JTT,LG,PMB,VT,WAG -m MFP -T 1 -alrt 1000 -fast"
       [ "$search_thoroughness" == "low" ] && IQTmod="-s \$file -st $mol_type -mset LG,VT,WAG -m MFP -T 1 -alrt 1000 -fast"
       [ "$search_thoroughness" == "lowest" ] && IQTmod="-s \$file -st $mol_type -mset LG -m MFP -T 1 -alrt 1000 -fast"
       fext="faaln"
       cmd="${distrodir}/run_parallel_cmmds.pl $fext '${bindir}/iqtree $IQTmod'"
       (( DEBUG > 0 )) && msg "PROT IQT_gene_trees command: $cmd" DEBUG NC
   fi

   # NOTE: to execute run_parallel_cmmds.pl with a customized command, resulting from the interpolation of multiple varialbles,
   #	   we have first to save the command line in a variable and pipe its content into bash for execution.
   #     Then we can execute run_parallel_cmmds.pl with a customized command, interpolating multiple varialbles
   (( DEBUG > 0 )) && msg " > $cmd | bash &> /dev/null" DEBUG NC
   { echo "$cmd" | bash &> /dev/null && return 0; } # 
      
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

function compute_IQT_gene_tree_stats()
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local mol_type search_thoroughness i N
   mol_type=$1
   search_thoroughness=$2
     
   [ "$mol_type" == "DNA" ] && s_type="IQTdnaT${search_thoroughness}"
   [ "$mol_type" == "PROT" ] && s_type="IQTprotT${search_thoroughness}"
  
   # prepare temporal header
   echo -e "model\tcount" > model_count_header.tmp

   # generate computation-time, lnL and best-model stats for IQT-computed gene trees
   grep '^Total wall-clock' ./*log | cut -d: -f1,3 | perl -pe 's/:\h+/\t/; s/\s+sec.*$//'  > tot_wcsecs_IQT_mset_gtrees.tsv
   grep '^Total CPU time used' ./*log | cut -d: -f1,3 | perl -pe 's/:\h+/\t/; s/\s+sec.*$//'  > tot_CPUsecs_IQT_mset_gtrees.tsv
   grep '^BEST SCORE' ./*log | sort -nrk5 | cut -d: -f1,3 | perl -pe 's/\h+/\t/; s/://' > sorted_IQT_lnL_mset_gene_trees.tsv
   grep '^BEST SCORE' ./*log | cut -d: -f1,3 | perl -pe 's/\h+/\t/; s/://' > sorted_by_FILE_NAME_lnL_mset_gene_trees.tsv
   grep '^Best-fit model' ./*log | cut -d' ' -f1,3 | perl -pe 's/:\S+/\t/' > IQT_best_models_for_gene_tree.tsv
   cut -f2 IQT_best_models_for_gene_tree.tsv | sort | uniq -c | awk 'BEGIN{OFS="\t"}{print $2,$1}' > IQT_best_model_counts_for_gene_trees.tsv
   
   cat model_count_header.tmp IQT_best_model_counts_for_gene_trees.tsv > k && mv k IQT_best_model_counts_for_gene_trees.tsv
   [ -s IQT_best_model_counts_for_gene_trees.tsv ] && rm model_count_header.tmp
   
   [ -s s_type.txt ] && rm s_type.txt
   N=$(find . -name "*.log" | wc -l)
   i=0
   for (( i=1; i<=N; i++ )); do
       echo "$s_type" >> s_type.txt
   done

   echo -e "alignment\twc_secs\tCPU_secs\tlnL\tmodel\ts_type" > IQT_gene_tree_stats.header
  
   if [ -s tot_wcsecs_IQT_mset_gtrees.tsv ] && [ -s tot_CPUsecs_IQT_mset_gtrees.tsv ] && [ -s sorted_by_FILE_NAME_lnL_mset_gene_trees.tsv ] && \
      [ -s IQT_best_models_for_gene_tree.tsv ] && [ -s s_type.txt ]
   then
   	# paste src files into table
   	paste tot_wcsecs_IQT_mset_gtrees.tsv tot_CPUsecs_IQT_mset_gtrees.tsv sorted_by_FILE_NAME_lnL_mset_gene_trees.tsv IQT_best_models_for_gene_tree.tsv s_type.txt > \
   	"IQT_${mol_type}_gene_tree_T${search_thoroughness}_stats.tsv"
   	check_output "IQT_${mol_type}_gene_tree_T${search_thoroughness}_stats.tsv" "$parent_PID"
   
   	# fix columns and add header
   	cut -f1,2,4,6,8,9 "IQT_${mol_type}_gene_tree_T${search_thoroughness}_stats.tsv" > k && mv k "IQT_${mol_type}_gene_tree_T${search_thoroughness}_stats.tsv"
   	cat IQT_gene_tree_stats.header "IQT_${mol_type}_gene_tree_T${search_thoroughness}_stats.tsv" > k && mv k "IQT_${mol_type}_gene_tree_T${search_thoroughness}_stats.tsv"

   	# cleanup
   	rm tot_wcsecs_IQT_mset_gtrees.tsv tot_CPUsecs_IQT_mset_gtrees.tsv sorted_by_FILE_NAME_lnL_mset_gene_trees.tsv \
   	IQT_best_models_for_gene_tree.tsv IQT_gene_tree_stats.header s_type.txt
   	rm ./*.ckp.gz
   
   	mkdir iqtree_output_files && mv ./*.iqtree ./*.bionj ./*.mldist ./*model.gz ./*uniqueseq.phy iqtree_output_files
   	[ -d iqtree_output_files ] && tar -czf iqtree_output_files.tgz iqtree_output_files && rm -rf iqtree_output_files
   	check_output iqtree_output_files.tgz "$parent_PID"
   fi
  (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
  return 0
}
#-----------------------------------------------------------------------------------------

function compute_MJRC_tree()
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local ext algo contree_outfile
   
   ext="$1"
   algo="$2"
       
   if [ "$algo" == "F" ]; then
       contree_outfile=FT_MJRC_tree.nwk
	    #labelled_contree_outfile=FT_MJRC_tree_ed.nwk
   else
        contree_outfile=IQT_MJRC_tree.nwk   
        #labelled_contree_outfile=IQT_MJRC_tree_ed.nwk   
   fi
   
   cat ./*."${ext}" > alltrees.nwk
   
   [ -s alltrees.nwk ] && { "$bindir"/iqtree -con alltrees.nwk &> /dev/null && return 0 ; }
   [ -s alltrees.nwk.contree ] && mv alltrees.nwk.contree "$contree_outfile" && rm alltrees.nwk.log
   
   # NOTE: Possible Bug in IQ-TREE v1.6.2 and v1.6.3, 
   #          IQT v1.6.2 and v1.6.3, but not v1.6.1!, cannot compute the mjrc tree from the debug set,
   #          claiming that the number of taxa are different across trees when running with FT ???
   #          There is not problem with the IQ-TREE run on the same sequences...
   #          >>> Therefore check_output was changed for simple warning messages to avoid premature exit <<<
   [ ! -s "$contree_outfile" ] && msg " >>> Warning, $contree_outfile was not produced!" WARNING LRED
   [ -s "$contree_outfile" ] && msg " >>> Wrote file $contree_outfile ... " PROGR GREEN
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   
   #"$distrodir"/add_labels2tree.pl "$top_dir"/tree_labels.list $contree_outfile &> /dev/null
   # check_output "$labelled_contree_outfile"
   return 0
}

# NOTE: this consense-based version does not work if trees have different number of nodes! Use iqtree-based function above
#function compute_MJRC_tree()
#{
#     (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
#
#     src_tree_ext=$1
#    
#     # 1 compute MJRE consensus tree with consense; 
#     #   >>> WATCH OUT! does not work with trees with different number of leaves
#     cat ./*$src_tree_ext > intree
#     echo "y" > consense.cmd
#
#     consense < consense.cmd
#     check_output outtree "$parent_PID"
#
#      #5.5 concatenated prefix required by run compute_suppValStas_and_RF-dist.R
#      #ln -s outtree concatenated.ph
#
#     #5.6 compute average bipartition support values for each gene tree
#     #	 and their RF-fistance to the consensus tree computed with consense
#   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
#}
#-----------------------------------------------------------------------------------------

function run_ASTRAL()
{
   # estimate species trees from multiple source gene trees
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local gene_trees num_markers tree_labels_dir num_threads
   gene_trees=$1
   num_markers=$2
   tree_labels_dir=$3
   num_threads=$4

   local ASTER_search_rounds=20
   local ASTER_subsampling_rounds=20
   
   local concat_aln=''
   
   # 1. Run ASTRAL-IV to estimat unrooted species tree from unrooted gene tree topologies with integrated CASTLES-II for branch lengths
   # ASTRAL-IV re-implements ASTRAL as a scalable alternative to ASTRAL on datasets for which ASTRAL is not suitable 
   # (e.g. large datasets, multi-individual, and gene trees with missing taxa). 
   # ASTRAL-IV also integrates CASTLES-II and thus computes terminal and internal branch lengths in substitution-per-site units
   (( DEBUG > 0 )) && msg " > $bindir/astral4 -i $gene_trees -o astral4_species_tree.tre 2> astral4.log" DEBUG NC
   "$bindir"/astral4 -r "$ASTER_search_rounds" -s "$ASTER_subsampling_rounds" -i "$gene_trees" -o astral4_top"${num_markers}"geneTrees.sptree -t "$num_threads" 2> astral4.log
   check_output "astral4_top${num_markers}geneTrees.sptree" "$parent_PID"
    
   "${distrodir}"/add_labels2tree.pl "${tree_labels_dir}"/tree_labels.list "astral4_top${num_markers}geneTrees.sptree" &> /dev/null
   check_output "astral4_top${num_markers}geneTrees_ed.sptree" "$parent_PID"
   
   # 2. Run wASTRAL
   # Weighted ASTRAL series introduce threshold-free weighting schemes for the quartet-based species tree inference, the metric used in ASTRAL. 
   # By reducing the impact of quartets with low support or long terminal branches (or both), weighting provides stronger theoretical guarantees 
   # and better empirical performance than the unweighted ASTRAL. 
   # weighted ASTRAL improves the utility of summary methods and can reduce the incongruence often observed across analytical pipelines.
   
   # Run wastral to estimate unrooted species tree from unrooted gene trees with branch lengths and Bootstrap/Bayesian/alrt supports 
   # assuming that horizontal gene transfers and hybridizations are rare. It utilizes branch lengths and supports to improve accuracy.
   (( DEBUG > 0 )) && msg " > $bindir/wastral -i $gene_trees -o wastral_species_tree.tre 2> wastral.log" DEBUG NC
   "$bindir"/wastral -r "$ASTER_search_rounds" -s "$ASTER_subsampling_rounds" -i "$gene_trees" -o wastral_top"${num_markers}"geneTrees.sptree -t "$num_threads" 2> wastral.log
   check_output "wastral_top${num_markers}geneTrees.sptree" "$parent_PID"
    
   "${distrodir}"/add_labels2tree.pl "${tree_labels_dir}"/tree_labels.list "wastral_top${num_markers}geneTrees.sptree" &> /dev/null
   check_output "wastral_top${num_markers}geneTrees_ed.sptree" "$parent_PID"
   
   # 3. select best-fitting model for concat_cdnAlns.fnainf using the wASTRAL species tree as fixed user-tree
   if [ "$mol_type" == "DNA" ]
   then
       concat_aln=concat_cdnAlns.fnainf
       lmsg=" # computing best-fitting model for $concat_aln using fixed user-tree wASTRAL species tree"
       msg "$lmsg" PRGR LBLUE
       iqtree -s "$concat_aln" -m MF+ASC+F+G+R*ASC*F*G*R -g "wastral_top${num_markers}geneTrees.sptree" \
       --prefix wastral_usertree_concat_model_selection -nt "$num_threads" -mset HKY,TN,TNef,TIM,TIMef,TVM,TVMef,SYM,GTR -cmax 15 --fast --quiet
   
       best_wastral_constrained_IQT_concat_model=''
       best_wastral_constrained_IQT_concat_model=$(awk '/chosen according to BIC/{print $3}' wastral_usertree_concat_model_selection.log)
   
       if [[ -n "$best_wastral_constrained_IQT_concat_model" ]]
       then
            msg " >>> best fit model for $concat_aln using fixed user-tree wASTRAL species tree: $best_wastral_constrained_IQT_concat_model" PROG GREEN
       else
            msg " >>> WARNING: could not compute best fit model for $concat_aln using fixed user-tree wASTRAL species tree" WARNING LRED
	    best_wastral_constrained_IQT_concat_model=GTR+G+F
       fi
   else
       concat_aln=concat_protAlns.faainf
       lmsg=" # computing best-fitting model for $concat_aln using fixed user-tree wASTRAL species tree"
       msg "$lmsg" PRGR LBLUE
       
       # NOTE: mixture models + ASC not yet implemented in iqtree v2.3.1 (Mar 25, 2024) 
       iqtree -s "$concat_aln" -m MF+F+G+R -g "wastral_top${num_markers}geneTrees.sptree" \
       --prefix wastral_usertree_concat_model_selection -nt "$num_threads" -mset EX2,EX3,LG4M,LG4X,EHO,UL2,UL3,EX_EHO -cmax 10 --fast --quiet
   
       best_wastral_constrained_IQT_concat_model=''
       best_wastral_constrained_IQT_concat_model=$(awk '/chosen according to BIC/{print $3}' wastral_usertree_concat_model_selection.log)
   
       if [[ -n "$best_wastral_constrained_IQT_concat_model" ]]
       then
            msg " >>> best fit model for $concat_aln using fixed user-tree wASTRAL species tree: $best_wastral_constrained_IQT_concat_model" PROG GREEN
       else
            msg " >>> WARNING: could not compute best fit model for $concat_aln using fixed user-tree wASTRAL species tree" WARNING LRED
	    best_wastral_constrained_IQT_concat_model=LG+G
       fi
   fi
   
   # 4. compute_ASTRALspTree_branch_lenghts using best_wastral-constrained_IQT_concat_model and concat_cdnAlns.fnainf
   if [ "$mol_type" == "DNA" ]
   then
        concat_aln=concat_cdnAlns.fnainf
   else
        concat_aln=concat_protAlns.faainf
   fi
  
   compute_ASTRALspTree_branch_lenghts "$concat_aln" "$best_wastral_constrained_IQT_concat_model" wastral_top"${no_top_markers}"geneTrees.sptree "$num_threads"
   
   # 5.1 compute the gene concordance factor (gCF) for each branch of the ASTRAL-IV species tree 
   # as the fraction of decisive gene trees concordant with this branch
   # NOTE: the IQTree_constrained_by_ASTRALspTree_concord.cf.tree produced by IQT may not be visualizable with FigTree!!!
   msg "# computing  the gene concordance factor (gCF) for each branch of the ASTRALIV species tree ..." PROGR LBLUE
   long_msg=" > iqtree -t astral4_top${num_markers}geneTrees.sptree --gcf alltrees.nwk --prefix astral4_concord &> /dev/null"
   (( DEBUG > 0 )) && msg "$long_msg" DEBUG NC
   iqtree -t astral4_top"${num_markers}"geneTrees.sptree --gcf alltrees.nwk --prefix astral4_concord &> /dev/null
   check_output astral4_concord.cf.tree "$parent_PID"

   # 5.2 add labels to astral4_concord.cf.tree
   "${distrodir}"/add_labels2tree.pl "${tree_labels_dir}"/tree_labels.list astral4_concord.cf.tree &> /dev/null
   if [[ -s astral4_concord_ed.cf ]] 
   then
       mv astral4_concord_ed.cf astral4_concord_ed_cf.treefile
       check_output astral4_concord_ed_cf.treefile "$parent_PID"
   else
       msg "WARNING: astral4_concord_ed_cf.treefile was not produced ..." WARNING LRED
   fi

   # 5.3 compute the gene concordance factor (gCF) for each branch of the wASTRAL species tree 
   msg "# computing  the gene concordance factor (gCF) for each branch of the wASTRAL species tree ..." PROGR LBLUE
   long_msg=" > iqtree -t wastral_top${num_markers}geneTrees.sptree --gcf alltrees.nwk --prefix wastral_concord &> /dev/null"
   (( DEBUG > 0 )) && msg "$long_msg" DEBUG NC
   iqtree -t wastral_top"${num_markers}"geneTrees.sptree --gcf alltrees.nwk --prefix wastral_concord &> /dev/null
   check_output wastral_concord.cf.tree "$parent_PID"

   # 5.4 add labels to wastral_concord.cf.tree
   "${distrodir}"/add_labels2tree.pl "${tree_labels_dir}"/tree_labels.list wastral_concord.cf.tree &> /dev/null
   if [[ -s wastral_concord_ed.cf ]] 
   then
       mv wastral_concord_ed.cf wastral_concord_ed_cf.treefile
       check_output wastral_concord_ed_cf.treefile "$parent_PID"
   else
       msg "WARNING: wastral_concord_ed.cf was not produced ..." WARNING LRED
   fi
   
   # 6.1 compute mean gCF from astral4_concord.cf.stat
   awk 'BEGIN{FS=OFS="\t"; print "num_branches\tcum_gCF\tmean_branch_gCF"}NR > 1{branches++; gCFcum+=$2;} 
      END{print branches, gCFcum, gCFcum/branches}' astral4_concord.cf.stat > astral4_concord_mean_gCF.tsv

   # 6.2 compute mean gCF from wastral_concord.cf.stat
   awk 'BEGIN{FS=OFS="\t"; print "num_branches\tcum_gCF\tmean_branch_gCF"}NR > 1{branches++; gCFcum+=$2;} 
      END{print branches, gCFcum, gCFcum/branches}' wastral_concord.cf.stat > wastral_concord_mean_gCF.tsv
   
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

function compute_ASTRALspTree_branch_lenghts()
{
   # uses iqtree to compute an wASTRAL species tree with branch lenghts 
   #  - needs the concatenated alignment, the model and the wASTRAL species tree topology, 
   #    which will be used by iqtree as a constrain
   #  iqtree -s concat_cdnAlns.fnainf -m GTR+F+ASC+R6 -g wastral_top92geneTrees.sptree --prefix IQTree_constrained_by_wASTRALspTree -T 12
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   
   local concat_aln model astral_spTree threads long_msg prefix
   concat_aln=$1
   model=$2
   astral_spTree=$3  
   threads=$4
   
   prefix=IQTree_constrained_by_wASTRALspTree

# ======================================================================================================================================
# >>> NOTE ON BUG: IQ-Tree v2.2.0 seems to have a bug, as it dumps a core (see below) when threads=AUTO in the following line:
# iqtree -s $concat_aln -m $model -g $astral_spTree --prefix IQTree_constrained_by_ASTRALspTree -T $threads

#132  132    0.00%    passed	14.07%
#****  TOTAL    0.00%  73 sequences failed composition chi2 test (p-value<5%; df=3)
#Reading constraint tree astral_top112geneTrees.sptree...
#WARNING: Rooted constraint tree will be treated as unrooted tree
#NOTE: 95 is identical to 94 but kept for subsequent analysis
#Checking for duplicate sequences: done in 0.0302344 secs using 474.9% CPU

#CHECKPOINT: Initial tree restored

#NOTE: 1319 MB RAM (1 GB) is required!
#Measuring multi-threading efficiency up to 56 CPU cores
#Increase to 10 rounds for branch lengths
#ERROR: phylotree.cpp:909: virtual void PhyloTree::initializeAllPartialLh(): Assertion `indexlh == nodeNum-leafNum' failed.
#ERROR: STACK TRACE FOR DEBUGGING:
#ERROR: 
#ERROR: *** IQ-TREE CRASHES WITH SIGNAL ABORTED
#ERROR: *** For bug report please send to developers:
#ERROR: ***    Log file: IQTree_constrained_by_ASTRALspTree.log
#ERROR: ***    Alignment files (if possible)
#Aborted (core dumped)
   
# changinng threads=12 runs smoothly!!   
#----------------------------------------------------------------------------------------------------------------------------------------   

   [[ "$threads" == 'AUTO' ]] && threads=10 # see note above on but in IQ-Tree 2.2.0 <<< !!!!
   
   # compute ML branch lenghts of wASTRAL species tree with IQT using the best model found for concat_aln
   msg "# computing ML branch lenghts of wASTRAL species tree with IQT using the best model found for concat_aln ..." PROGR LBLUE
   long_msg=" > iqtree -s $concat_aln -m $model -g $astral_spTree --prefix $prefix -T $threads &> /dev/null"
   (( DEBUG > 0 )) && msg "$long_msg" DEBUG NC
   iqtree -s "$concat_aln" -m "$model" -g "$astral_spTree" --prefix "$prefix" -T "$threads" &> /dev/null
   
   # the IQT implementaion in v2.2.0 seems to be buggy, as for the same data
   #  the previous call is sometimes not successful (particularly in the Travis environment)
   #  therefore here we do not use check_output, but rather a simple -s test.
   if [[ -s ${prefix}.treefile ]]
   then
       # add labels to IQTree_constrained_by_ASTRALspTree.treefile
       "${distrodir}"/add_labels2tree.pl "${tree_labels_dir}"/tree_labels.list ${prefix}.treefile &> /dev/null
        check_output ${prefix}_ed.treefile "$parent_PID"
   else
       msg "WARNING: ${prefix}.treefile was not produced!" WARNING LRED
   fi
   
   #(( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

function process_IQT_species_trees_for_molClock()
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC    
    (( DEBUG > 0 )) && caller 0
    local best_search_base_name best_tree_file top_markers_dir no_top_markers
    best_search_base_name=$1
    best_tree_file=$2
    top_markers_dir=$3
    no_top_markers=$4
    
    (( DEBUG > 0 )) && msg "Received: best_search_base_name:$best_search_base_name | best_tree_file:$best_tree_file ..." DEBUG NC     
    # cp the treefile $top_markers_dir for compute_suppValStas_and_RF-dist.R
    mv "${best_search_base_name}.treefile" "${best_tree_file}" && cp "${best_tree_file}" "$top_markers_dir"

    # label the species tree
    print_start_time && msg "# Adding labels back to ${best_tree_file} ..." PRGR BLUE
    (( DEBUG > 0 )) && msg " > ${distrodir}/add_labels2tree.pl ${tree_labels_dir}/tree_labels.list ${best_tree_file} &> /dev/null" DEBUG NC
    "${distrodir}"/add_labels2tree.pl "${tree_labels_dir}"/tree_labels.list "${best_tree_file}" &> /dev/null
    check_output "${best_tree_file}" "$parent_PID"

    rm ./*.ckp.gz concat_cdnAlns.fnainf
    mkdir iqtree_output_files || { msg "ERROR: mkdir iqtree_output_files failed!" ERROR RED && exit ; }
    mv ./*.iqtree ./*.bionj ./*.mldist "${best_tree_file}" iqtree_output_files   
    if ls ./*.uniqueseq.phy &> /dev/null; then mv ./*.uniqueseq.phy iqtree_output_files; fi
 
    "$distrodir"/rename.pl 's/_ed\.treefile/_ed\.sptree/' ./*_ed.treefile
    [ -d iqtree_output_files ] && cp iqtree_output_files/"${best_tree_file}" .
    cp ./*_ed.sptree sorted_IQ-TREE_searches.out "$top_markers_dir"
    
    [ -d iqtree_output_files ] && tar -czf iqtree_output_files.tgz iqtree_output_files && rm -rf iqtree_output_files
    check_output iqtree_output_files.tgz "$parent_PID"

    cd "$top_markers_dir" || { msg "ERROR: cannot cd into $top_markers_dir!" ERROR RED && exit ; }
    rm concat_cdnAlns.fnainf.treefile 
    #rename 's/\.treefile/\.ph/' ./*.treefile

    #best_tree_file=$(ls ./concat_nonRecomb_KdeFilt_cdnAlns_iqtree_*_ed.ph)
    #ln -s ${best_tree_file} ${best_tree_file%.*}.treefile
     
    # run compute RF-dist to species tree 
    (( DEBUG > 0 )) && echo "running compute_suppValStas_and_RF-dist.R in " && pwd
    print_start_time && msg "# computing the mean support values and RF-distances of each gene tree to the concatenated tree ..." PROGR BLUE
    (( DEBUG > 0 )) && msg " > ${distrodir}/compute_suppValStas_and_RF-dist.R $top_markers_dir 2 fasta treefile 1 &> /dev/null" DEBUG NC
    "${distrodir}"/compute_suppValStas_and_RF-dist.R "$top_markers_dir" 2 fasta treefile 1 &> /dev/null
    
    check_output gene_trees2_concat_tree_RF_distances.tab "$parent_PID"
    
    # remove the unlabeled concat*treefile species tree required for compute_suppValStas_and_RF-dist.R
    # to avoid interference with clock-test, if required
    [ -s gene_trees2_concat_tree_RF_distances.tab ] && rm concat_*.treefile
    
    # need to remove the double extension name and change treefile for ph to make it paup-compatible, if clock-test is to be run
    "${distrodir}"/rename.pl 's/\.fasta\.treefile/\.ph/' ./*.fasta.treefile
    
    # top100_median_support_values4loci.tab should probably not be written in the first instance
    [ -s top100_median_support_values4loci.tab ] && (( no_top_markers < 101 )) && rm top100_median_support_values4loci.tab

   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

function concat_alns()
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
    (( DEBUG > 0 )) && caller 0
    local aln_ext pPID
    aln_ext=$1
    pPID=$2

    ls -1 ./*"${aln_ext}" > list2concat
    check_output list2concat "$parent_PID"

    if [ "$mol_type" == "DNA" ]
    then
        concat_file="concat_cdnAlns.fna"
    fi

    if [ "$mol_type" == "PROT" ]
    then
        concat_file="concat_protAlns.faa"
    fi

    "${distrodir}"/concat_alignments.pl list2concat > "$concat_file"
    #concat_alignments.pl list2concat > $concat_file
    check_output "$concat_file" "$pPID"
    perl -ne 'if (/^#|^$/){ next }else{print}' "$concat_file" > k && mv k "$concat_file"
    (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

function fix_fastaheader()
{
   # extract the relevant fields from the long '|'-delimited fasta headers generated by get_homologues
   # to construct a shorte one, suitable for display as tree labels
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local file
   file=$1
   awk 'BEGIN {FS = "|"}{print $1, $2, $3}' "$file" | 
     perl -pe 'if(/^>/){s/>\S+/>/; s/>\h+/>/; s/\h+/_/g; s/,//g; s/;//g; s/://g; s/\(//g; s/\)//g}' > "${file}ed";

   check_output "${file}ed" "$parent_PID"
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

function get_critical_TajD_values()
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local no_seq
   no_seq=$1
   TajD_low=$(awk -v n="$no_seq" '$1 == n' "${distrodir}"/pop_gen_tables/TajD_predicted_CIs.tsv|cut -d' ' -f2)
   TajD_up=$(awk -v n="$no_seq" '$1 == n' "${distrodir}"/pop_gen_tables/TajD_predicted_CIs.tsv|cut -d' ' -f3)
   echo "$TajD_low $TajD_up"
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
}
#-----------------------------------------------------------------------------------------

function get_critical_FuLi_values()
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   local no_seq
   no_seq=$1
   FuLi_low=$(awk -v n="$no_seq" 'BEGIN{FS="\t"}$1 == n' "${distrodir}"/pop_gen_tables/Fu_Li_predicted_CIs.tsv|cut -f2)
   FuLi_up=$(awk -v n="$no_seq" 'BEGIN{FS="\t"}$1 == n'  "${distrodir}"/pop_gen_tables/Fu_Li_predicted_CIs.tsv|cut -f3)
   echo "$FuLi_low $FuLi_up"
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
    return 0
}
#-----------------------------------------------------------------------------------------

function check_output()
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
    (( DEBUG > 0 )) && caller 0
    local outfile pPID
    outfile=$1
    pPID=$2

    if [ -s "$outfile" ]
    then
         msg " >>> wrote file $outfile ..." PROGR GREEN
        (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
    else
        echo
	msg " >>> ERROR! The expected output file $outfile was not produced, will exit now!" ERROR RED
        echo
	exit 9
	(( DEBUG > 0 )) && msg "check_output running: kill -9 $pPID" DEBUG NC
	kill -9 "$pPID"
    fi
    return 0
}

#-----------------------------------------------------------------------------------------

function check_IQT_DNA_models()
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
    (( DEBUG > 0 )) && caller 0
    # https://unix.stackexchange.com/questions/299217/grepping-array-from-file-and-reusing-search-pattern
    # https://stackoverflow.com/questions/21058210/use-grep-on-array-to-find-words
    # https://www.linuxquestions.org/questions/linux-newbie-8/split-a-string-into-array-in-bash-869196/

    # NOTE: DNA substitution models changed substantially between IQ-TREE version 1.5.6 and 1.6.1
    local model_string modelOK usr_models dna_models u m
    model_string="$1"
    modelOK=0
    #usr_models=($(echo "$model_string" | tr "," " "))
    # SC2207 requires 4.4+, must not be in posix mode, may use temporary files
    # mapfile -t array < <(mycommand)
    mapfile -t usr_models < <( (echo "$model_string" | tr "," " ") )

    dna_models=(JC F81 K2P HKY TrN TNe K3P K81u TPM2 TPM2u TPM3 TPM3u TIM TIMe TIM2 TIM2e TIM3 TIM3e TVM TVMe SYM GTR)

    for u in "${usr_models[@]}"
    do
        for m in "${dna_models[@]}"
	do
	    if echo "$u" | grep -q "$m" &> /dev/null
	    then
		 modelOK=1
		 break
	    fi
	done

        if ((modelOK != 1))
        then
           msg "ERROR: model $u is not available in IQ-TREE" ERROR RED
	   print_help
	   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
	   exit 1
        fi
	modelOK=0
    done
    (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
    return 0
}

#-----------------------------------------------------------------------------------------

function check_IQT_PROT_models
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
    (( DEBUG > 0 )) && caller 0

    # https://unix.stackexchange.com/questions/299217/grepping-array-from-file-and-reusing-search-pattern
    # https://stackoverflow.com/questions/21058210/use-grep-on-array-to-find-words
    # https://www.linuxquestions.org/questions/linux-newbie-8/split-a-string-into-array-in-bash-869196/

    # NOTE: protein matrixes changed substantially between IQ-TREE version 1.5.6 and 1.6.1
    local model_string modelOK usr_models dna_models u m
    model_string="$1"
    modelOK=0
    #usr_models=( $(echo "$model_string" | tr "," " ") )
    # SC2207 requires 4.4+, must not be in posix mode, may use temporary files
    # mapfile -t array < <(mycommand)
    mapfile -t usr_models < <( (echo "$model_string" | tr "," " ") )
    
    dna_models=(BLOSUM62 cpREV Dayhoff DCMut FLU HIVb HIVw JTT JTTDCMut LG mtART mtMAM mtREV mtZOA Poisson PMB rtREV VT WAG)

    for u in "${usr_models[@]}"
    do
        for m in "${dna_models[@]}"
	do
	    if echo "$u" | grep -q "$m" &> /dev/null
	    then
		 modelOK=1
		 break
	    fi
	done

        if ((modelOK != 1))
        then
           msg "ERROR: model $u is not available in IQ-TREE" ERROR RED
	   print_help
       fi
	modelOK=0
    done
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

function msg()
{
    #(( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
    (( DEBUG > 0 )) && caller 0
    local msg mtype col
    msg=$1
    mtype=$2
    col=$3
    
    NC='\033[0m'

    case $col in
       RED) col='\033[0;31m';;
       LRED) col='\033[1;31m';;
       GREEN) col='\033[0;32m';;
       YELLOW) col='\033[1;33m';;
       BLUE) col='\033[0;34m';;
       LBLUE) col='\033[1;34m';;
       CYAN) col='\033[0;36m';;
       NC) col='\033[0m';;
    esac

    case $mtype in
       HELP)  printf "\n${col}%s${NC}\n\n" "$msg" >&2;;
       ERROR)  printf "\n${col}%s${NC}\n\n" "$msg" >&2 | tee -a "${logdir}/get_phylomarkers_run_${dir_suffix}_${TIMESTAMP_SHORT}.log";;
       WARNING) printf "${col}%s${NC}\n" "$msg" >&1 | tee -a "${logdir}/get_phylomarkers_run_${dir_suffix}_${TIMESTAMP_SHORT}.log";;
       PROGR)  printf "${col}%s${NC}\n" "$msg" >&1 | tee -a "${logdir}/get_phylomarkers_run_${dir_suffix}_${TIMESTAMP_SHORT}.log";;
       DEBUG)  printf "${col}%s${NC}\n" "$msg" >&1 | tee -a "${logdir}/get_phylomarkers_run_${dir_suffix}_${TIMESTAMP_SHORT}.log";;
       VERBOSE)  printf "${col}%s${NC}\n" "$msg" >&1 | tee -a "${logdir}/get_phylomarkers_run_${dir_suffix}_${TIMESTAMP_SHORT}.log";;
    esac
   #(( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]}  ..." DEBUG NC
   return 0
}
#-----------------------------------------------------------------------------------------

parse_SRH_tests() {
   # This function parses tables generated by the maximal matched-pairs tests of homogeneity 
   #   to asses the SRH model violations.
   # SRH = Stationarity, Reversibility, and Homogeneity assumptions made by standard substitutio models
   # The test is implemented in IQ-Tree, as published by Naser-Khdour et al. (2019) in GBE 11(12)3341-3352.
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]}  ..." DEBUG NC
   (( DEBUG > 0 )) && caller 0
   
   local ext fasta_base
   ext=$1
   
   for f in *"${ext}"
   do 
      fasta="${f/.symtest.csv/}"
      perc_failed_comp_ChiSq=$(grep TOTAL "${fasta}".log | sed 's/\*\*\*\*  //' | awk '{print $2}')
      num_failed_comp_ChiSq=$(grep TOTAL "${fasta}".log | sed 's/\*\*\*\*  //' | awk '{print $3}')
      SymPval=$(grep Noname "$f" | awk 'BEGIN{FS=","}{print $4}')
      MarPval=$(grep Noname "$f" | awk 'BEGIN{FS=","}{print $7}')
      IntPval=$(grep Noname "$f" | awk 'BEGIN{FS=","}{print $10}')
    
      # print parsed output line
      echo -e "$fasta\t$SymPval\t$MarPval\t$IntPval\t$perc_failed_comp_ChiSq\t$num_failed_comp_ChiSq"     
   done > parsed_SRHtests.tsv   
   check_output parsed_SRHtests.tsv "$parent_PID"

   # identify the alignments passing the SRHtests
   awk 'BEGIN{FS=OFS="\t"; print "alignment\tSymPval\tMarPval\tIntPval\tperc_failed_comp\tnum_failed_comp"}
     $2 > 0.05 && $3 > 0.05 && $4 > 0.05' parsed_SRHtests.tsv > SRHtests_passed.tsv
   check_output SRHtests_passed.tsv "$parent_PID"

   # identify alignments failing the symtests
   awk 'BEGIN{FS=OFS="\t"; print "alignment\tSymPval\tMarPval\tIntPval\tperc_failed_comp\tnum_failed_comp"}
      $2 <= 0.05 || $3 <= 0.05 || $4 <= 0.05' parsed_SRHtests.tsv > SRHtests_failed.tsv
   check_output SRHtests_failed.tsv "$parent_PID"

   no_alns_failing_SRHtests=$(awk 'NR > 1' SRHtests_failed.tsv | wc -l) # remove header

   msg " >>> $no_alns_failing_SRHtests codon alignments failed the SRH tests" PROGR GREEN

   # Move failed symtest FASTA files (codon and faaln to their directory
   if ((no_alns_failing_SRHtests >= 1)) && [[ -s SRHtests_failed.tsv ]]; then
      mkdir SRHtests_failed || { msg "ERROR: could not mkdir SRHtests_failed/" ERROR RED && exit 1 ; }
      for f in $(awk 'BEGIN{FS="\t"}NR > 1{print $1}' SRHtests_failed.tsv); do
          fasta_base="${f/_cdnAln.*/}" 
          mv "${fasta_base}"* SRHtests_failed
      done
   fi

   # cleanup
   (( DEBUG > 0 )) && msg "DEGUB: creating SRHtests_failed.tgz and removing SRHtests_failed/" DEBUG NC
   [ -d SRHtests_failed ] && tar -czf SRHtests_failed.tgz SRHtests_failed
   [ -s SRHtests_failed.tgz ] && rm -rf SRHtests_failed

   (( DEBUG > 0 )) && msg "DEGUB: creating SRHtests_OK/ and SRHtests_OK.tgz/" DEBUG NC
   mkdir SRHtests_OK || { msg "ERROR: could not mkdir SRHtests_OK/" ERROR RED && exit 1 ; }
   if [ -d SRHtests_OK ]
   then
      mv ./*cdnAln.fasta.log SRHtests_OK
      mv ./*fasta.symtest.csv SRHtests_OK
      tar -czf SRHtests_OK.tgz SRHtests_OK || { msg "ERROR: could not make tgz SRHtests_OK.tgz" ERROR RED && exit 1 ; }
      [ -s SRHtests_OK.tgz ] && rm -rf SRHtests_OK
   fi
   
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC

   return 0
}
