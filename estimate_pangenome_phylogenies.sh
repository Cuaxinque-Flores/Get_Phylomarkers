#!/usr/bin/env bash

#-------------------------------------------------------------------------------------------------------
#: PROGRAM: estimate_pangenome_phylogenies.sh
#: AUTHOR: Pablo Vinuesa, Center for Genomic Sciences, UNAM, Mexico
#:         http://www.ccg.unam.mx/~vinuesa/
#
#: PROJECT START: October 28th, 2017
#
#: AIM: run PHYLIP's seqboot and pars methods in parallel for a bootstrap analysis 
#       of a pangenome matrix generated by the comparte_clusters.pl script
#       of the get_homologues suite. 

#: OUTPUT: a pars phylogeny with bootstrap values mapped on it

#: COPYRIGHT (c) 2017, Pablo Vinuesa. Released under the GNU-license. 
#                                     http://www.gnu.org/copyleft/gpl.html

#### DEPENDENCIES 
# Assumes that the following binaries and scripts are all in $PATH, checked by check_dependencies()
#
#   1) Binaries from the PHYLIP package: 
#	seqboot pars consense
#   2) Modified PHYLIP binaries:  
#       consense   # <<< NOT STRICTLY REQUIRED!
# REF:
# Shimada MK, Nishida T. A modification of the PHYLIP program: A solution for
# the redundant cluster problem, and an implementation of an automatic
# bootstrapping on trees inferred from original data. Mol Phylogenet Evol. 2017
# Apr;109:409-414. doi: 10.1016/j.ympev.2017.02.012. PubMed PMID:28232198.
# https://github.com/ShimadaMK/PHYLIP_enhance/

#   3) uses nw_reroot and nw_support from the newick_utils package 
#      to remap the bootstrap proportions on the orignal tree
# REF:
# Thomas Junier and Evgeny M. Zdobnov (2010). Bioinformatics  26:1669-1670
# http://bioinformatics.oxfordjournals.org/content/26/13/1669.full
# doi:10.1093/bioinformatics/btq243
# http://cegg.unige.ch/newick_utils

#: TODO
#-------------------------------------------------------------------------------------------------------

# Set Bash strict mode
# http://redsymbol.net/articles/unofficial-bash-strict-mode/
#set -euo pipefail
#set -e   # NOTE: fails in first call to "run_parallel_cmmds.pl faaed 'add_nos2fasta_header.pl $file"; L973 
set -u
set -o pipefail

progname=${0##*/}
VERSION='v1.2.3_18Nov22' # mostly shellcheck compliant; enabled bash strict mode; major syntax revision and update to modern Bash; 
                         #  added IQT_threads=4 && updated iqtree2 calls with -T $IQT_threads instead of -T AUTO, which slows down searches
       # v1.2.2_15Nov22 updated iqtree calls to match current IQTreee2 syntax
       #'v1.2.1_04Oct21' #v1.2.1_04Oct21; preppended missing "${bindir}" to first pars call
       # v1.2_16Sep21 added function check_libnw() for lib /usr/local/lib/libnw.so.0.0.0; -R 3 only warns if could not write full_pars_tree_rooted_withBoot.ph
       # v.1.2_10Jan20; added option -S <abayes|UFBoot|both> default: $IQT_support
       #'1.0.5_28Mar18' # check_scripts_in_path() checks wether USER is regular or root
       #'1.0.4_17Feb18' # prepended $bindir/ to a nw_reroot call that was missing it
       # 1.0.3_8Feb18 added -v; check_scripts_in_path(); check_dependencies with verbosity; activated set_pipeline_environment; Thanks Felipe Lira!
        # fix in set_pipeline_environment: changed to readlink -n when "$OSTYPE" == "darwin" 
       # v1.0_23Jan18 added code to run IQ-TREE on PGM, including alrt/UFBoot and model selection
       # v0.2_2Nov17; added runmodes and code to run parallel pars searches with different 
                   #            random seeds; Selects best tree; improved/fixed basic documentation
       #'0.1_27Oct17'; first fully working version

# GLOBALS
#DATEFORMAT_SHORT="%d%b%y" # 16Oct13

#TIMESTAMP_SHORT=$(date +${DATEFORMAT_SHORT})

date_F=$(date +%F |sed 's/-/_/g')-   # 2013_10_20
date_T=$(date +%T |sed 's/:/./g')    # 23.28.22 (hr.min.secs)
start_time="$date_F$date_T"

sleeptime=30
topdir=$(pwd)
declare -A pids

# initialize variables
runmode=''
criterion=ML
discrete_model=BIN
input_fasta=''
num_IQT_runs=1
IQT_support=both #<abayes|UFBoot|both>
IQT_threads=4

input_phylip=''
n_cores=50
boot=2
n_jumbles=20
t_jumbles=1
DEBUG=0
sequential=1
rnd_no=33
outgroup=1
phylo=''
pars_tree=''

check_version=0

#---------------------------------------------------------------------------------#
#>>>>>>>>>>>>>>>>>>>>>>>>>>>> FUNCTION DEFINITIONS <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<#
#---------------------------------------------------------------------------------#
function msg()
{
    #[ "$DEBUG" -eq 1 ] && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    msg=$1
    mtype=$2
    col=$3

    NC='\033[0m'

    case $col in
       RED) col='\033[0;31m';;
       LRED) col='\033[1;31m';;
       GREEN) col='\033[0;32m';;
       YELLOW) col='\033[1;33m';;
       BLUE) col='\033[0;34m';;
       LBLUE) col='\033[1;34m';;
       CYAN) col='\033[0;36m';;
       NC) col='\033[0m';;
    esac

    case $mtype in
       HELP)  printf "\n${col}%s${NC}\n\n" "$msg" >&2;;
       ERROR)  printf "\n${col}%s${NC}\n\n" "$msg" >&2;;
       WARNING) printf "${col}%s${NC}\n" "$msg" ;;
       PROGR)  printf "${col}%s${NC}\n" "$msg" ;;
       DEBUG)  printf "${col}%s${NC}\n" "$msg" ;;
       VERBOSE)  printf "${col}%s${NC}\n" "$msg" ;;
    esac
   #[ "$DEBUG" -eq 1 ] && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}
#-----------------------------------------------------------------------------------------

function set_bindirs()
{
    [ "$DEBUG" -eq 1 ] && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    # receives: $bindir $homebinpathflag
    bindir=$1

    # prepend $bindir to $PATH in any case, to ensure that the script runs with the distributed binaries in $bindir
    export PATH="${bindir}:${PATH}"

   #echo $setbindir_flag
   [ "$DEBUG" -eq 1 ] && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}
#-----------------------------------------------------------------------------------------

function set_pipeline_environment()
{
   local scriptdir distrodir bindir OS no_cores 

   if [[ "$OSTYPE" == "linux-gnu" ]]
   then
    scriptdir=$(readlink -f "${BASH_SOURCE[0]}")
    distrodir=$(dirname "$scriptdir") #echo "scriptdir: $scriptdir|basedir:$distrodir|OSTYPE:$OSTYPE"
    bindir="$distrodir/bin/linux"
    OS='linux'
    no_cores=$(awk '/^processor/{n+=1}END{print n}' /proc/cpuinfo)
  elif [[ "$OSTYPE" == "darwin"* ]]
  then
    distrodir=$(cd "$scriptdir" || { msg "ERROR: cannot cd into $scriptdir" ERROR RED && exit 1 ; })
    bindir="$distrodir/bin/macosx-intel"
    OS='darwin'
    no_cores=$(sysctl -n hw.ncpu)
  fi
  echo "$distrodir $bindir $OS $no_cores"
}
#----------------------------------------------------------------------------------------------#

function get_script_PID()
{
    local prog proc_ID
    #(( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    # returns the PID of the script, run by USER
    prog=${0%.*} # remove the script's .extension_name
    #proc_ID=$(ps -eaf|grep "$prog"|grep -v grep|grep '-'|grep $USER|awk '{print $2}')
    #proc_ID=$(ps aux|grep "$prog"|grep -v grep|grep '-'|grep "$USER" |awk '{print $2}')
    proc_ID=$(pgrep -u "$USER" "$prog")
    echo "$proc_ID"
    (( DEBUG > 0 )) && msg "$progname PID is: $proc_ID" DEBUG NC
    #(( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}
#-----------------------------------------------------------------------------------------

function print_start_time()
{
   #echo -n "[$(date +%T)] "
   printf '%(%T )T' '-1' # requires Bash >= 4.3
}

#----------------------------------------------------------------------------------
function wait_for_PIDs_to_finish
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
   local flag PID sleeptime
   declare -A pids=$1
   flag=0

   while [ "$flag" -eq 0 ] 
   do
     for PID in "${pids[@]}"
     do
       #echo "PID is $PID"
       flag=1
       ps -ef | grep "${PID}" | grep -v 'grep' &> /dev/null
       r=${?}

       if [ ${r} -eq 0 ]
       then 
         flag=0
         sleep "$sleeptime"
       fi
     done
   done

   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}
#--------------------------------------------- #

function check_scripts_in_path()
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    local perl_scripts prog distrodir not_in_path prog bin

    distrodir=$1
    not_in_path=0
    homebinflag=0
    homebinpathflag=0
    
    (( DEBUG > 0 )) && msg "check_scripts_in_path() distrodir:$distrodir" DEBUG NC

    perl_scripts=( run_parallel_cmmds.pl rename.pl add_labels2tree.pl )

    # check if scripts are in path; if not, set flag
    for prog in "${perl_scripts[@]}"
    do
       bin=$(type -P "$prog")
       if [ -z "$bin" ]; then
          echo
          if [ "$USER" == "root" ]
	  then
	      msg "# WARNING: script $prog is not in \$PATH!" WARNING LRED
	      msg " >>>  Will generate a symlink from /usr/local/bin or add it to \$PATH" WARNING CYAN
	      not_in_path=1
	  else
	      msg "# WARNING: script $prog is not in \$PATH!" WARNING LRED
	      msg " >>>  Will generate a symlink from $HOME/bin or add it to \$PATH" WARNING CYAN
	      not_in_path=1
	  fi
       fi
    done

    # if flag $not_in_path -eq 1, then either generate symlinks into $HOME/bin (if in $PATH) or export $distrodir to PATH
    if (( not_in_path == 1 ))
    then
       if [ "$USER" == "root" ]
       then
       	   if [ ! -d /usr/local/bin ]
       	   then
          	   msg "Could not find a /usr/local/bin directory for $USER ..."  WARNING CYAN
	  	   msg " ... will update PATH=$distrodir:$PATH"  WARNING CYAN
	  	   export PATH="${distrodir}:${PATH}" # prepend $ditrodir to $PATH
       	   else
           	   homebinflag=1
       	   fi

       	   # check if $HOME/bin is in $PATH
       	   if echo "$PATH" | sed 's/:/\n/g' | grep "/usr/local/bin$" &> /dev/null
       	   #if [ $? -eq 0 ]
       	   then
          	   homebinpathflag=1

          	   msg "Found dir /usr/local/bin for $USER in \$PATH ..." WARNING CYAN
          	   msg " ... will generate symlinks in /usr/local/bin to all scripts in $distrodir ..." WARNING CYAN
          	   ln -s "$distrodir"/*.sh /usr/local/bin &> /dev/null
          	   ln -s "$distrodir"/*.R /usr/local/bin &> /dev/null
          	   ln -s "$distrodir"/*.pl /usr/local/bin &> /dev/null
       	   else
          	   msg " Found dir /usr/local/bin for $USER, but it is NOT in \$PATH ..." WARNING CYAN
          	   msg " ... updating PATH=$PATH:$distrodir" WARNING CYAN
	  	   export PATH="${distrodir}:${PATH}" # prepend $distrodir to $PATH
       	   fi
       else       
       	   if [ ! -d "$HOME"/bin ]
       	   then
          	   msg "Could not find a $HOME/bin directory for $USER ..."  WARNING CYAN
	  	   msg " ... will update PATH=$distrodir:$PATH"  WARNING CYAN
	  	   export PATH="${distrodir}:${PATH}" # prepend $ditrodir to $PATH
       	   else
           	   homebinflag=1
       	   fi

       	   # check if $HOME/bin is in $PATH
       	   if echo "$PATH" | sed 's/:/\n/g'| grep "$HOME/bin$" &> /dev/null
       	   #if [ $? -eq 0 ]
       	   then
          	   homebinpathflag=1

          	   msg "Found dir $HOME/bin for $USER in \$PATH ..." WARNING CYAN
          	   msg " ... will generate symlinks in $HOME/bin to all scripts in $distrodir ..." WARNING CYAN
          	   ln -s "$distrodir"/*.sh "$HOME"/bin &> /dev/null
          	   ln -s "$distrodir"/*.R "$HOME"/bin &> /dev/null
          	   ln -s "$distrodir"/*.pl "$HOME"/bin &> /dev/null
          	   #ln -s $distrodir/rename.pl $HOME/bin &> /dev/null
       	   else
          	   msg " Found dir $HOME/bin for $USER, but it is NOT in \$PATH ..." WARNING CYAN
          	   msg " ... updating PATH=$PATH:$distrodir" WARNING CYAN
	  	   export PATH="${distrodir}:${PATH}" # prepend $distrodir to $PATH
       	   fi
       fi
    fi
    (( DEBUG > 0 )) && echo "$homebinflag $homebinpathflag"
    (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}
#-----------------------------------------------------------------------------------------

function check_libnw()
{
    if [ ! -s /usr/local/lib/libnw.so ]
    then
         cat <<NWUTIL
         WARNING: lib libnw.so was not found in /usr/local/lib!
     
         If you you want to use the parsimony module, then you will need to do the following:
         1. cp /path/to/get_phylomarkers/lib/libnw.so /usr/local/lib 
         2. add the following line to your .bashrc or .bash_profile file in your home
            export LD_LIBRARY_PATH=\$LD_LIBRARY_PATH:/usr/local/lib
         3. open a new terminal or source the edited .bashrc or .bash_profile
            source ~/.bashrc or source ~/.bash_profile
        
         4. Reconfigure libs:
             sudo ldconfig
NWUTIL

     fi
}
#-----------------------------------------------------------------------------------------

function check_dependencies
{
     # check if scripts are in path; if not, set flag
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    local programname bin 

    #local VERBOSITY=$1
    #local GREEN='\033[0;32m'
    local NC='\033[0m'

    # check that the following PHYLIP binaries and nw_* tools are in $PATH; die if not
    for programname in iqtree seqboot pars consense nw_reroot nw_support add_labels2tree.pl
    do
       bin=$(type -P "$programname")
       if [ -z "$bin" ]; then
          echo
          echo "# ERROR: $programname not in place!"
          echo "# ... you will need to install \"$programname\" first or include it in \$PATH"
          echo "# ... exiting"
          exit 1
       #else
       #   [ "$VERBOSITY" -eq 1 ] && printf "${GREEN}%s${NC}\n"  "# $programname OK!"
       fi
    done

    echo
    echo '# Run check_dependencies() ... looks good;) all required binaries and scripts are in place.'
    echo
    (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}
#---------------------------------------------------------------------------------#

function check_output()
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    local outfile pPID
    
    outfile=$1
    pPID=$2

    if [ -s "$outfile" ]
    then
         msg " >>> wrote file $outfile ..." PROGR GREEN
	 return 0
    else
        echo
	msg " >>> ERROR! The expected output file $outfile was not produced, will exit now!" ERROR RED
        echo
	exit 9
	[ "$DEBUG" -eq 1 ] && msg "check_output running: kill -9 $pPID" DEBUG NC
	kill -9 "$pPID"
    fi
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}
#----------------------------------------------------------------------------------

function run_IQT_discrete
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    local input_fasta discrete_model nrep_IQT_searches IQT_support wkdir lmsg
    
    input_fasta=$1
    discrete_model=$2
    nrep_IQT_searches=$3
    IQT_support=$4
    
    wkdir=''
    lmsg=''
    
    if [ "$nrep_IQT_searches" -eq 1 ]; then
        wkdir=$(pwd)
	(( DEBUG > 0 )) && msg "working in $wkdir" DEBUG NC	
	
	if [ "$IQT_support" == "both" ]
	then
	    lmsg=" # running iqtree -s $input_fasta -st $discrete_model -m MFP -T $IQT_threads -abayes -B 1000 &> /dev/null"
	    print_start_time && msg "$lmsg" PROGR BLUE
            "${bindir}"/iqtree -s "$input_fasta" -st "$discrete_model" -m MFP -T "$IQT_threads" -abayes -B 1000 &> /dev/null 
	
	    best_model=$(grep '^Best-fit model' "${input_fasta}".log | cut -d' ' -f 3)
	    msg " >>> Best-fit model: ${best_model} ..." PROGR GREEN
            treefile=PGM_IQT_${best_model}_${IQT_support}.treefile
	    mv pangenome_matrix_t0.fastaed.treefile "$treefile"
	    check_output "$treefile"
	    msg " ... found in $wkdir" PROGR GREEN
	    msg " ... done!" PROGR GREEN
	
            # cleanup
	    rm ./*.ckp.gz
       elif [ "$IQT_support" == "abayes" ]
       then
	    lmsg=" # running iqtree -s $input_fasta -st $discrete_model -m MFP -T $IQT_threads -abayes &> /dev/null"
	    print_start_time && msg "$lmsg" PROGR BLUE
            "${bindir}"/iqtree -s "$input_fasta" -st "$discrete_model" -m MFP -T "$IQT_threads" -abayes &> /dev/null 
	
	    best_model=$(grep '^Best-fit model' "${input_fasta}".log | cut -d' ' -f 3)
	    msg " >>> Best-fit model: ${best_model} ..." PROGR GREEN
            treefile=PGM_IQT_${best_model}_${IQT_support}.treefile
	    mv pangenome_matrix_t0.fastaed.treefile "$treefile"
	    check_output "$treefile"
	    msg " ... found in $wkdir" PROGR GREEN
	    msg " ... done!" PROGR GREEN
	
            # cleanup
	    rm ./*.ckp.gz       
       else
	    lmsg=" # running iqtree -s $input_fasta -st $discrete_model -m MFP -T $IQT_threads -B 1000 &> /dev/null"
	    print_start_time && msg "$lmsg" PROGR BLUE
            "${bindir}"/iqtree -s "$input_fasta" -st "$discrete_model" -m MFP -T "$IQT_threads" -B 1000 &> /dev/null 
	
	    best_model=$(grep '^Best-fit model' "${input_fasta}".log | cut -d' ' -f 3)
	    msg " >>> Best-fit model: ${best_model} ..." PROGR GREEN
            treefile=PGM_IQT_${best_model}_${IQT_support}.treefile
	    mv pangenome_matrix_t0.fastaed.treefile "$treefile"
	    check_output "$treefile"
	    msg " ... found in $wkdir" PROGR GREEN
	    msg " ... done!" PROGR GREEN
	
            # cleanup
	    rm ./*.ckp.gz
       fi	    
    else
        wkdir=$(pwd)
	[ "$DEBUG" -eq 1 ] && msg "working in $wkdir" DEBUG NC
	# 1. first run without testing branch supports, to find the best-fitting model
	print_start_time && msg " >>> running iqtree -s $input_fasta -st $discrete_model to find best model" PROGR GREEN
        "${bindir}"/iqtree -s "$input_fasta" -st "$discrete_model" -m MF -T $IQT_threads &> /dev/null
	
	best_model=$(grep '^Best-fit model' "${input_fasta}".log | cut -d' ' -f 3)
	msg " >>> Best-fit model: ${best_model} ..." PROGR GREEN
        
	# 2. generate multirun_dir and launch searches from within
	multirun_dir="iqtree_${nrep_IQT_searches}_runs"
	mkdir "$multirun_dir" && cd "$multirun_dir" && ln -s ../"$input_fasta" .
	msg " ... created and moved into dir $multirun_dir" PROGR LBLUE
	
	wkdir=$(pwd)
	
	if [ "$IQT_support" == "both" ]
	then
   	    lmsg="# Will sequentially launch $num_IQT_runs IQ-TREE searches on the supermatrix with best model ${best_model} -abayes -bb 1000!.
		   This will take a while ..."
	    print_start_time && msg "$lmsg" PROGR BLUE

	    # run nrep_IQT_searches IQ-TREE searches under the best-fit model found
	    for ((rep=1;rep<=nrep_IQT_searches;rep++))
	    do
	        lmsg="> iqtree -s $input_fasta -st $discrete_model -m $best_model -abayes -B 1000 -T $IQT_threads -pre abayes_UFBboot_run${rep} &> /dev/null"
	        print_start_time && msg "$lmsg" PROGR LBLUE

	        iqtree -s "$input_fasta" -st "$discrete_model" -m "$best_model" -abayes -B 1000 -T "$IQT_threads" -pre "abayes_UFBboot_run${rep}" &> /dev/null
	    done

	    grep '^BEST SCORE' ./*log | sed 's#./##' | sort -nrk5 > sorted_lnL_scores_IQ-TREE_searches.out
	    check_output sorted_lnL_scores_IQ-TREE_searches.out 

	    best_search=$(head -1 sorted_lnL_scores_IQ-TREE_searches.out)
	    best_search_base_name=$(head -1 sorted_lnL_scores_IQ-TREE_searches.out | cut -d\. -f 1)

	    msg " >>> Best IQ-TREE run was: $best_search ..." PROGR GREEN
	    best_tree_file=best_PGM_IQT_${best_search_base_name}_${best_model}.treefile
	    mv "${best_search_base_name}".treefile "$best_tree_file"
	
	    check_output "$best_tree_file"
	    msg " ... found in $wkdir" PROGR GREEN
	    msg " ... done!" PROGR GREEN
	
	    # cleanup
	    rm ./*.ckp.gz
	elif [ "$IQT_support" == "abayes" ]
	then
   	    lmsg="# Will sequentially launch $num_IQT_runs IQ-TREE searches on the supermatrix with best model ${best_model} -abayes!.
		   This will take a while ..."
	    print_start_time && msg "$lmsg" PROGR BLUE

	    # run nrep_IQT_searches IQ-TREE searches under the best-fit model found
	    for ((rep=1;rep<=nrep_IQT_searches;rep++))
	    do
	        lmsg="> iqtree -s $input_fasta -st $discrete_model -m $best_model -abayes -T $IQT_threads -pre abayes_run${rep} &> /dev/null"
	        print_start_time && msg "$lmsg" PROGR LBLUE

	        iqtree -s "$input_fasta" -st "$discrete_model" -m "$best_model" -abayes -T "$IQT_threads" -pre "abayes_run${rep}" &> /dev/null
	    done

	    grep '^BEST SCORE' ./*log | sed 's#./##' | sort -nrk5 > sorted_lnL_scores_IQ-TREE_searches.out
	    check_output sorted_lnL_scores_IQ-TREE_searches.out 

	    best_search=$(head -1 sorted_lnL_scores_IQ-TREE_searches.out)
	    best_search_base_name=$(head -1 sorted_lnL_scores_IQ-TREE_searches.out | cut -d\. -f 1)

	    msg " >>> Best IQ-TREE run was: $best_search ..." PROGR GREEN
	    best_tree_file=best_PGM_IQT_${best_search_base_name}_${best_model}.treefile
	    mv "${best_search_base_name}".treefile "$best_tree_file"
	
	    check_output "$best_tree_file"
	    msg " ... found in $wkdir" PROGR GREEN
	    msg " ... done!" PROGR GREEN
	
	    # cleanup
	    rm ./*.ckp.gz
	else
   	    lmsg="# Will sequentially launch $num_IQT_runs IQ-TREE searches on the supermatrix with best model ${best_model} -UFBoot!.
		   This will take a while ..."
	    print_start_time && msg "$lmsg" PROGR BLUE

	    # run nrep_IQT_searches IQ-TREE searches under the best-fit model found
	    for ((rep=1;rep<=nrep_IQT_searches;rep++))
	    do
	        lmsg="> iqtree -s $input_fasta -st $discrete_model -m $best_model -B 1000 -T $IQT_threads -pre UFBoot_run${rep} &> /dev/null"
	        print_start_time && msg "$lmsg" PROGR LBLUE

	        iqtree -s "$input_fasta" -st "$discrete_model" -m "$best_model" -B 1000 -T "$IQT_threads" -pre "UFBoot_run${rep}" &> /dev/null
	    done

	    grep '^BEST SCORE' ./*log | sed 's#./##' | sort -nrk5 > sorted_lnL_scores_IQ-TREE_searches.out
	    check_output sorted_lnL_scores_IQ-TREE_searches.out 

	    best_search=$(head -1 sorted_lnL_scores_IQ-TREE_searches.out)
	    best_search_base_name=$(head -1 sorted_lnL_scores_IQ-TREE_searches.out | cut -d\. -f 1)

	    msg " >>> Best IQ-TREE run was: $best_search ..." PROGR GREEN
	    best_tree_file=best_PGM_IQT_${best_search_base_name}_${best_model}.treefile
	    mv "${best_search_base_name}".treefile "$best_tree_file"
	
	    check_output "$best_tree_file"
	    msg " ... found in $wkdir" PROGR GREEN
	    msg " ... done!" PROGR GREEN
	
	    # cleanup
	    rm ./*.ckp.gz
	
	fi
	    
    fi	
   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}


#------------------------------------------------------------------------------------#
# >>> Functions to write the command files to pass parameters to PHYLIP programs <<< #
#------------------------------------------------------------------------------------#

function write_pars_full_search_cmd
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    local n_jumbles sequential i rseed
    
    n_jumbles=$1
    sequential=$2
    i=$3
    
    if [ -z "$i" ]
    then
       rseed=$rnd_no
    else
       # compute a new rdm number for each new iteration of the loop
       # to maximize randomness in bootstrapping.
       rseed=$((8*i+1))
    fi

    # need to remove previous param file, since we are concatenating to it
    [ -s pars.params ] && rm pars.params
    
    touch pars.params
    
   [ "$sequential" -eq 0 ] &&  echo -ne "J\n$rseed\n$n_jumbles\nY\n" > pars.params
   [ "$sequential" -gt 0 ] &&  echo -ne "J\n$rseed\n$n_jumbles\nI\nY\n" > pars.params

   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}

#----------------------------------------------------------------------------------
function write_boot_pars_params
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    #get the input runmodes, models, bootstrap no. ...
    local boot sequential n_jumbles i rdm
    
    boot=$1
    sequential=$2
    n_jumbles=$3
    i=$4

    # compute a new rdm number for each new iteration of the loop
    # to maximize randomness in bootstrapping.
    rdm=$((4*i+1))

    # need to remove previous param file, since we are concatenating to it
    [ -s pars.params ] && rm pars.params
    
    touch pars.params
    
    [ "$sequential" -eq 0 ] && echo -ne "M\nD\n$boot\n$rdm\n$t_jumbles\nY\n" > pars.params
    [ "$sequential" -gt 0 ] && echo -ne "M\nD\n$boot\n$rdm\n$t_jumbles\nI\nY\n" > pars.params
  
    (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}

#----------------------------------------------------------------------------------
function write_seqboot_params
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    #get the input runmodes, models and bootstrap no.
    local boot i rdm
    boot=$1
    i=$2
    
    # compute a new rdm number for each new iteration of the loop
    # to maximize randomness in bootstrapping.
    rdm=$((4*i+1))
    
    # need to remove previous param file, since we are concatenating to it
    [ -s seqboot.params ] && rm seqboot.params
    
    touch seqboot.params

    # Write Seqboot params
    (( boot > 0 )) && echo -ne "D\nR\n$boot\nY\n$rdm\n" > seqboot.params

    (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}
#----------------------------------------------------------------------------------
function write_consense_params
{
    (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
    # very difficult ;)
    [ -s consense.params ] && rm consense.params
    
    local outgroup
    outgroup=$1
    
    (( outgroup > 1 )) && echo -ne "O\n$outgroup\n"  >> consense.params 
    echo -ne "Y\n"                                   >> consense.params
 
    (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}

#----------------------------------------------------------------------------------
function print_warning
{
    local msg
    msg=$1
    echo "WARNING: $msg"
}
#----------------------------------------------------------------------------------
# don't leave litter behind ... remove intermediate input/output files
function cleanup_dir 
{
   (( DEBUG > 0 )) && msg " => working in ${FUNCNAME[0]} ..." DEBUG NC
   [ -s infile ] && rm infile
   [ -s outfile ] && rm outfile
   
   for file in ./*.params
   do
       [ -s "$file" ] && rm "$file"
   done    

   (( DEBUG > 0 )) && msg " <= exiting ${FUNCNAME[0]} ..." DEBUG NC
}

#----------------------------------------------------------------------------------
# <<<<<<<<<<< END PHYLIP FUNCTIONS >>>>>>>>>>> #
#----------------------------------------------#

function print_help
{
   cat<<EOF
   $progname v.$VERSION [OPTIONS]
   
   -h  prints this help message
   
 REQUIRED
   -f <input_fasta_pangenome_matrix>  [for IQ-TREE]
   -i <input_phylip_pangenome_matrix> [for pars]

   [NOTE: script should be called from with the folder containing the required input matrix]
 
 REQUIRED only if -c PARS
   -R <int> 
        1 launch single pars run  [ not particularly useful ]
	      2 launch n pars runs on n cores [ multiple independen searches, no bootstrapping ] 
	      3 automatic single pars run + bootstrap analysis [ recommended ]
	      4 map bootstrap props on selected -T tree_num found in -R 2 runs
   -T <string> pars tree to map the boot-props on (req. for -R 4)

 OPTIONAL  
   -c <string> optimalit criterion: [ML|PARS]        [default: $criterion]                         

 OPTIONAL to control IQ-TREE ML searches (-c ML)     [default: $discrete_model]
   -m <BIN|MORPH> discrete model category 
   -r <integer> number of independent iqtree runs    [default: $num_IQT_runs]           
                in the range 1:100
   -S <string> [<abayes|UFBoot|both>]                [default: $IQT_support]
 OPTIONAL to control parsimony searches when -c PARS:
   -n <number of compute cores to use to launch independent 
       pars runs, each with a different seed         [default: $n_cores]
   -b <integer> No. of pars runs or 
       bootstrap pseudoreplicates                    [default: $boot] 
                per compute node                     
   -j <integer> number of tax jumbles                [default: $n_jumbles]
                for full pars search	
   -t <integer> number of tax jumbles                [default: $t_jumbles]
                for pars search	on boot replicates

   -s <flag>    sequential matrix                    [default: $sequential]	

 OTHER optional 
   -D <flag> print debugging messages
        
 EXAMPLES:
 1) Search for the best maximum likelihood tree using 10 independent IQ-TREE runs
    $progname -f pangenome_matrix_t0.fasta -r 10 -S UFBoot

 2) PARSIMONY searches with pars; NOTE: VERY SLOW!
    nohup $progname -c PARS -R 1 -i pangenome_matrix_t0.phylip -j 50 &> /dev/null &
    nohup $progname -c PARS -R 2 -i pangenome_matrix_t0.phylip -n 50 -j 100 &> /dev/null &
    nohup $progname -c PARS -R 3 -i pangenome_matrix_t0.phylip -n 64 -b 64 -j 50 -t 1 &> /dev/null &
          $progname -c PARS -R 4 -T best_pars_tree_name (execute within boot_pars/ after -R 2 and -R 3 runs 
	                                have finished answering n to: should dir boot_pars be removed y|n? n)
	                              

 AIM: Estimate pan-genome phylogenies from the pangenome_matrix files computed by compare_clusters.pl
        of the GET_HOMOLOGUES suite. By default the script will estimate a ML phylogeny using the best-fit
	binary model. This is large the recommended use of the script, as it is MUCH FASTER.
	
      If desired the optimality criterion can be changed to parsimony (-c PARS) and the script will
      run PHYLIPs seqboot and pars programs in parallel on the pangenome_matrix_t0.phylip file to:
       1. search for the best pars tree using multiple seed trees (-R 2) or from a single one (-R 1, -R 3)
       2. bootstap the pan-genome phylogeny and map the boot-props to the pars phylogeny 
          [automatically -R 3 or on a user-specified best phylogeny -R 4 -T (best)_tree_file]

 NOTES ON PARS PARALLELIZATION: 
     1. The script runs as many subshells as n_cores indicated by the user 
        to parallelize the process, running n_boot replicates from each of the processes/subshells.  
        Therefore, to run 500 bootstrap replicates on 50 nodes, use -n 50 -b 10
     2. To make a thorough tree search (-R 2), define -n cores, which will launch -n processes/subshells,
        each with a different random seed number, each searching from -j jumbled seed trees. 
	To add boostrap support values to the best tree found in the search, you need first
	to launch a -R 3 run. Then, from within the boot_pars dir, call -R 4 as shown above
     	
  
       $progname is part of the GET_PHYLOMARKERS package
          released under the GNU General Public License http://www.gnu.org/copyleft/gpl.html
          and available at https://github.com/vinuesa/get_phylomarkers
  

EOF

exit 1   
}

#-------------------------------------------------------------------------------------------------#
#---------------------------------------- GET OPTIONS --------------------------------------------#
#-------------------------------------------------------------------------------------------------#

# GETOPTS
while getopts ':b:c:j:m:n:f:i:I:r:R:S:t:T:hsDv' OPTIONS; do
   case $OPTIONS in
   f)   input_fasta=$OPTARG
        ;;
   i)   input_phylip=$OPTARG
        ;;
   I)   IQT_threads=$OPTARG
        ;;
   b)   boot=$OPTARG
        ;;
   c)   criterion=$OPTARG
        ;;
   m)  	discrete_model=$OPTARG
        ;;
   n)  	n_cores=$OPTARG
        ;;
   h)   print_help
        ;;
   j)   n_jumbles=$OPTARG
        ;;
   r)	num_IQT_runs=$OPTARG
        ;;
   s)   sequential=1
        ;;
   S)   IQT_support=$OPTARG
        ;;
   t)   t_jumbles=$OPTARG
        ;;
   v)   echo "$progname v$VERSION" && check_version=1 && check_dependencies 1  && exit 0
        ;;
   D)   DEBUG=1
        ;;
   T)   pars_tree=$OPTARG
        ;;
   R)   runmode=$OPTARG
        ;;
   :)   printf "argument missing from -%s option\n" "$OPTARG"
   	 print_help
     	 exit 2 
     	 ;;
   \?)   echo "need the following args: "
   	 print_help
         exit 3
	 ;;
   esac >&2 
done

shift $((OPTIND - 1))


#-------------------------------------------------------#
# >>>BLOCK 0.1 SET THE ENVIRONMENT FOR THE PIPELINE <<< #
#-------------------------------------------------------#

# 0. Set the distribution base directory and OS-specific (linux|darwin) bindirs
env_vars=$(set_pipeline_environment) # returns: $distrodir $bindir $OS $no_proc
[ "$DEBUG" -eq 1 ] && echo "env_vars:$env_vars"
distrodir=$(echo "$env_vars" | awk '{print $1}')
bindir=$(echo "$env_vars" | awk '{print $2}')
OS=$(echo "$env_vars" | awk '{print $3}')
no_proc=$(echo "$env_vars" | awk '{print $4}')

#-----------------------------------------------------------------------------------------

[ "$DEBUG" -eq 1 ] && echo "distrodir:$distrodir|bindir:$bindir|OS:$OS|no_proc:$no_proc"

# 0.1 Determine if pipeline scripts are in $PATH;
# if not, add symlinks from ~/bin, if available
check_scripts_in_path "$distrodir"

# 0.2  Determine the bindir and add prepend it to PATH and export
set_bindirs "$bindir"

# 0.3 append the $distrodir/lib/R to R_LIBS and export
export R_LIBS="${distrodir}/lib/R"

# 0.4 append the $distrodir/lib/perl to PERL5LIB and export
export PERL5LIB="${distrodir}/lib/perl:${distrodir}/lib/perl/bioperl-1.5.2_102"


#--------------------------------------#
# >>> BLOCK 0.2 CHECK USER OPTIONS <<< #
#--------------------------------------#

[ "$check_version" -eq 1 ] && exit 0

if [ "$criterion" == "ML" ]; then
    [ -z "$input_fasta" ] && msg "# ERROR: no input fasta file defined!" ERROR RED && print_help && exit 1
    [ "$discrete_model" != "BIN" ] && [ "$discrete_model" != "MORPH" ] && msg "# ERROR: discrete model has to be 'BIN|MORPH'" ERROR RED && print_help && exit 1
    [ "$num_IQT_runs" -lt 1 ] || [ "$num_IQT_runs" -gt 100 ] && msg "# ERROR: the number of IQT runs should be in the 1:100 range" ERROR RED && print_help && exit 1
    if [ "$IQT_support" != 'abayes' ] && [ "$IQT_support" != 'UFBoot' ] && [ "$IQT_support" != 'both' ] 
    then
         msg "# ERROR: provide one of the following branch support value types for IQ-tree searches: abayes|UFBoot|both" ERROR RED && print_help && exit 1
    fi
fi


if [ "$criterion" == "PARS" ]; then
    if [ -z "$input_phylip" ] && [ "$runmode" -ne 4 ] # runmode 4 does not require the input phylip file
    then
       echo
       msg "# ERROR: no input phylip file defined!" ERROR RED
       print_help
    fi

    if [ -z "$runmode" ]
    then
       echo
       msg "# ERROR: no runmode defined for parsimony-based analyses!" ERROR RED
       print_help
    fi

    # First check that bootstrap value is an integer
    re='^[0-9]+$'
    if ! [[ "$boot" =~ $re ]]
    then
       echo
       msg "# ERROR: $boot is not an integer; provide a value between 100 and 1000" ERROR RED
       echo
       print_help
    fi

    echo
    msg "### $progname v.$VERSION run on $start_time with the following parameters:" PROGR YELLOW
    msg "# topdir = $topdir | criterion:$criterion" PROGR YELLOW
fi


if [ "$criterion" == "ML" ]; then
    msg "input_fasta: $input_fasta" PROGR YELLOW
    msg "discrete_model: $discrete_model" PROGR YELLOW
    msg "branch support type: $IQT_support" PROGR YELLOW
fi

if [ "$criterion" == "PARS" ]; then
    msg "# runmode = $runmode | input_phylip = $input_phylip | input_phylo = $phylo" PROGR YELLOW
    msg "# n_cores = $n_cores | bootstrap no. = $boot | n_jumbles_pars = $n_jumbles | t_jumbles_boot_pars = $t_jumbles" PROGR YELLOW
    msg "# DEBUG=$DEBUG" PROGR YELLOW
    echo
fi


#-------------------------------------------------------------------------------------------------#
#------------------------------------------ MAIN CODE --------------------------------------------#
#-------------------------------------------------------------------------------------------------#

wkdir=$(pwd)
top_dir=$(pwd)

# 1. Run maximum-likelihood tree searches on the pan-genome matrix with IQ-TREE, including model selection
if [ "$criterion" == "ML" ]; then
    msg " " PROGR NC
    msg " >>>>>>>>>>>>>>> ModelFinder + IQ-TREE run on pan-genome matrix <<<<<<<<<<<<<<< " PROGR YELLOW
    msg " " PROGR NC
   
    iqt_dir="iqtree_PGM_${num_IQT_runs}_runs"
   
    [ -d "$iqt_dir" ] && msg "# WARNING: $iqt_dir exists in $topdir!. Need to remove or rename it." WARNING LRED && exit 1
    mkdir "$iqt_dir" && cd "$iqt_dir" && ln -s ../"$input_fasta" .
    [ -d "$iqt_dir" ] && msg "...created and moved into subdir $iqt_dir" PROGR LBLUE
    sed 's#\.gb[fk]##g' "$input_fasta" > "${input_fasta}ed"
    [ "$DEBUG" -eq 1 ] && check_output "${input_fasta}ed"
    [ "$DEBUG" -eq 1 ] && msg "calling: run_IQT_discrete ${input_fasta}ed $discrete_model $num_IQT_runs $IQT_support in dir: $wkdir" DEBUG NC
    run_IQT_discrete "${input_fasta}ed" "$discrete_model" "$num_IQT_runs" "$IQT_support"
fi


# NOTE: THE PARS TREE SEARCHES ARE VERY SLOW!
      
# TODO: 1. improve/expand documentation, perhaps adding option -H
#       2. improve/expand error checking + progress messages
#       3. think of adding option -d to define wkdir and improve warning messages/handling
#            if -d dir exists, as a function of -R
#       4. Think of adding more runmodes ... 
#           (e.g. thorough tree searching + bootstrapping + transfer of boot-prop labels)



#>>>  run pars in multiple directories to parallelize
#       TODO: think of adding option -d to define wkdir and improve warning messages/handling
#            if -d dir exists, as a function of -R. For example:
#             1. automatically mv boot_pars to boot_parsback${TIMESTAMP_SHORT} if -R 1 
#             2. automatically cd into boot_pars if -R 2 -o -R 3

if [ "$criterion" == "PARS" ]; then

if [ -d boot_pars ] && [ "$runmode" -ne 4 ]
then
   msg "found dir boot_pars" WARNING LRED
   read -p "should dir boot_pars be removed y|n? " answer
   case "$answer" in
     [yY1] ) choice="y"
     ;;
     [nN0] ) choice="n"
     ;;
     *     ) printf "%b" "Unexpected asnwer '$answer'!" >&2 ;;
   esac  
     
   if [ "$choice" == "y" ]
   then
       rm -rf boot_pars
       mkdir boot_pars || { msg "ERROR: cannot make dir boot_pars" ERROR RED && exit 1 ; }
       cd boot_pars || { msg "ERROR: cannot cd into boot_pars" ERROR RED && exit 1 ; }
       wkdir=$(pwd)
   else    
       cd boot_pars || { msg "ERROR: cannot make dir boot_pars" ERROR RED && exit 1 ; }
       wkdir=$(pwd)
   fi
else
   (( runmode != 4 )) && mkdir boot_pars && cd boot_pars && wkdir=$(pwd)
fi


if (( runmode == 1 )) || (( runmode == 3 ))
then
  #pids=()
  # compute the full parsimony tree
  mkdir full_pars || { msg "ERROR: cannot mkdir full_pars" ERROR RED && exit 1 ; }
  cd full_pars || { msg "ERROR: cannot cd into full_pars" ERROR RED && exit 1 ; }
  msg " ... working in dir full_pars" PROGR LBLUE
  ln -s "$topdir/$input_phylip" infile

  if [ -e infile ]
  then    
     write_pars_full_search_cmd "$n_jumbles" "$sequential"
     "${bindir}"/pars < pars.params &> /dev/null & 
     cd "$wkdir" || { msg "ERROR: cannot cd into $wkdir" ERROR RED && exit 1 ; }
  else
     echo
     msg "# FATAL ERROR: input phylip file $input_phylip does not exist or is empty" ERROR RED
     msg "# Nothing to do. Exiting ..." ERROR RED
     echo
     exit 2
  fi

  #wait_for_PIDs_to_finish $pids; we wait in the parsing loop
fi

#>>> 2. Runmode -eq 2: launch multiple pars searches
if (( runmode == 2 ))
then
  # now run the individual pars searches from individual directories
  cd "$wkdir" || { msg "ERROR: cannot cd into $wkdir" ERROR RED && exit 1 ; }
  msg " ... working in dir $wkdir" PROGR LBLUE

  start=1
  end=$n_cores

  pids=()
  
  for ((i=start; i<=end; i++))
  do
      dirname="pars${i}" # <CHECK
    
      mkdir "$dirname" || { msg "ERROR: cannot make dir $dirname" ERROR RED && exit 1 ; }
      cd "$dirname" || { msg "ERROR: cannot cd into $dirname" ERROR RED && exit 1 ; }
      (( DEBUG > 1 )) && msg "moved into dir $dirname" DEBUG NC
    
      ln -s "$topdir/$input_phylip" infile
      [ ! -s infile ] && msg "ERROR no $input_phylip in $dirname" ERROR RED && exit

      # 2) lets remove old param files etc that would interfere ...
      # cleanup_dir  <== will be called at the end of the run

      # 3) lets get to business
      # 3.1) make sure we have an input file or die
      if [ -e infile ]
      then
         # 5. run pars
         [ "$DEBUG" -eq 1  ] &&  echo "# running write_dnapars_params $boot $sequential $n_jumbles"
         write_pars_full_search_cmd "$n_jumbles" "$sequential" "$i"
         msg "# running pars < pars.params &> /dev/null in $dirname" PROGR BLUE
         pars < pars.params &> /dev/null & 
         pids[$i]=${!}
         cd "$wkdir" || { msg "ERROR: cannot cd into $wkdir" ERROR RED && exit 1 ; }
      else
         echo
         msg "# FATAL ERROR: input phylip file $input_phylip does not exist or is empty" ERROR RED
         msg "# Nothing to do. Exiting ..." ERROR RED
	 echo
         exit
     fi
  done

  msg "# waiting for pars jobs to finish ..." PROGR LBLUE
  wait_for_PIDs_to_finish "$pids"
fi

#>>> Runmode -eq 3: now run the bootstrap replicates from individual directories
if (( runmode == 3 ))
then
  check_libnw
  cd "$wkdir" || { msg "ERROR: cannot cd into $wkdir" ERROR RED && exit 1 ; }
  start=1
  end="$n_cores"
 
  pids=()
 
  for ((i=start; i<=end; i++))
  do
     dirname="run${i}" # <CHECK
    
     mkdir "$dirname" || { msg "ERROR: cannot mkdir $dirname" ERROR RED && exit 1 ; }
     cd "$dirname" || { msg "ERROR: cannot cd into $dirname" ERROR RED && exit 1 ; }
     (( DEBUG == 1 )) && echo "moved into dir $dirname"
    
     ln -s "$topdir/$input_phylip" infile
     [ ! -s infile ] && msg "ERROR no $input_phylip in $dirname" ERROR RED && exit

     # 2) lets remove old param files etc that would interfere ...
     # cleanup_dir  <== will be called at the end of the run

     # 3) lets get to business
     # 3.1) make sure we have an input file or die
     if [ -e infile ]
     then
       # 4. run seqboot
       [ "$DEBUG" -eq 1 ] && msg "# running  write_seqboot_params $boot $i" DEBUG NC
       write_seqboot_params "$boot" "$i"
       [ "$DEBUG" -eq 1 ] && msg "# running seqboot < seqboot.params &> /dev/null" DEBUG NC
       "${bindir}"/seqboot < seqboot.params &> /dev/null
       mv outfile infile

      # 5. run pars
      [ "$DEBUG" -eq 1  ] &&  echo "# running write_dnapars_params $boot $sequential $t_jumbles $i"
       write_boot_pars_params "$boot" "$sequential" "$t_jumbles" "$i"
       msg "# running pars < pars.params &> /dev/null in $dirname" PROGR BLUE
       "${bindir}"/pars < pars.params &> /dev/null & 
       pids[$i]=${!}
       cd "$wkdir" || { msg "ERROR: cannot cd into $wkdir" ERROR RED && exit 1 ; }
     else
         echo
         msg "# FATAL ERROR: input phylip file $input_phylip does not exist or is empty" ERROR RED
         msg "# Nothing to do. Exiting ..." ERROR RED
	 echo
         exit
     fi
  done

  msg "# waiting for pars jobs to finish ..." PROGR LBLUE
  wait_for_PIDs_to_finish "$pids"
fi


# 2. wait until all pars jobs have finished
# wait until all pars jobs have finished
# ps -ux | awk '{print $2, $11}' | grep pars | awk '{print $1}'
# https://unix.stackexchange.com/questions/305039/pausing-a-bash-script-until-previous-commands-are-finished


#>>> 4. parse the parsimony search results
if (( runmode == 2 ))
then
    sleep 10 # make sure all writing to dirs has finished
    
    cd "${top_dir}"/boot_pars || { msg "ERROR: cannot cd into ${top_dir}/boot_pars" ERROR RED && exit 1 ; }
    msg "# will parse multisearch results in dir ${top_dir}/boot_pars" PROGR LBLUE
    start=1
    end=$n_cores

    for ((i=start; i<=end; i++))
    do
       d="pars${i}" #<CHEK
       score=$(grep '^requires' ${d}/outfile | perl -pe 's/requires a total of\h+//')    
       echo -e "$d\t$score"
    done > pars_search_scores.tsv
    
    check_output pars_search_scores.tsv
    
    grep '^pars' pars_search_scores.tsv | sort -nk2 > t && mv t pars_search_scores.tsv
    cut -f2 pars_search_scores.tsv | uniq -c > pars_search_profile_stats.tsv

    best_pars_run_dir=$(head -1 pars_search_scores.tsv | cut -f1)
    best_pars_run_score=$(head -1 pars_search_scores.tsv | cut -f2)
    
    echo -e "$best_pars_run_dir\t$best_pars_run_score" >  best_pars_run_ID_and_score.tsv
    check_output best_pars_run_ID_and_score.tsv
    
    best_pars_tree="best_pars_tree_${best_pars_run_dir}J${n_jumbles}n${n_cores}.ph"
    best_pars_tree_outfile="best_pars_tree_${best_pars_run_dir}J${n_jumbles}n${n_cores}.outfile"
    cp "$best_pars_run_dir"/outtree "$best_pars_tree"
    cp "$best_pars_run_dir"/outfile "$best_pars_tree_outfile"
    
    check_output "$best_pars_tree"
    check_output "$best_pars_tree_outfile"
fi

#>>> 5. Run consense and nw_* tools after all pars jobs have finished
#    to remap boostrap proportions on the original pars tree
if [ "$runmode" -eq 3 ]
then
  cd "${top_dir}"/boot_pars || { msg "ERROR cannot cd into ${top_dir}/boot_pars" ERROR RED; exit 1 ; }
  sleep 10 # make sure all I/O has finished
  msg "# working in $wkdir ..." PROGR LBLUE
  start=1
  end="$n_cores"

  # 3.1 concatenate all src bootstrap trees (outtree) in the working directories
  for ((i=start; i<=end; i++))
  do
    dirname="run${i}" # <CHECK
    cat "${dirname}"/outtree >> outtree
  done

  # rename the src bootstrap trees
  cp outtree intree
  mv outtree all_boottrees.ph

  # 3.2 run consense; just a double check
  (( DEBUG > 1 )) && msg "# running write_consense_params" DEBUG NC
  write_consense_params "$outgroup"
  (( DEBUG > 1 )) && msg "# running consense < consense.params &> /dev/null" DEBUG NC
  "${bindir}"/consense < consense.params &> /dev/null 
  mv outtree consense.outtree
  mv outfile consense.outfile

  # 3.3 get the real parsimony tree and rename it
  cp full_pars/outtree full_pars_tree.ph

  # 3.4 arbitrarily root trees at first taxon labeled 0000000000 with nw_reroot
  (( DEBUG > 1 )) && msg "# running nw_reroot full_pars_tree.ph 0000000000 > full_pars_tree_rooted.ph" DEBUG NC
  "${bindir}"/nw_reroot full_pars_tree.ph 0000000000 > full_pars_tree_rooted.ph
  perl -pe 's/\n//; s/;/;\n/' full_pars_tree.ph > t && mv t full_parsimony_tree.ph 

  (( DEBUG > 1 )) && msg "# running nw_reroot all_boottrees.ph 0000000000 > all_boottrees_rooted.ph" DEBUG NC
  "${bindir}"/nw_reroot all_boottrees.ph 0000000000 > all_boottrees_rooted.ph

  # 3.5 add bootstrap values to full_pars_tree_rooted.ph with nw_support
  # https://www.biostars.org/p/99308/ # Treeio And Bootstrap Values
  # https://www.biostars.org/p/95948/ # Merging Bootstrap Values And Posterior Probabilities
  # http://treethinkers.blogspot.mx/2008/10/labeling-trees-posterior-probability.html
  # http://treethinkers.blogspot.mx/2008/07/r-tip-indicating-tree-support.html
  # 
  (( DEBUG > 1 )) && msg "# running nw_support -p full_pars_tree_rooted.ph all_boottrees_rooted.ph > full_pars_tree_rooted_withBoot.ph" DEBUG NC
  "${bindir}"/nw_support -p full_pars_tree_rooted.ph all_boottrees_rooted.ph > full_pars_tree_rooted_withBoot.ph

  # 4. add proper lebels to full_pars_tree_rooted_withBoot.ph
  [ ! -s pangenome_matrix_t0.tab ] && ln -s ../pangenome_matrix_t0.tab .
  [ ! -s pangenome_matrix_t0.phylip ] && ln -s ../pangenome_matrix_t0.phylip .

  awk '{print $1}' pangenome_matrix_t0.tab | sed 's/\.gbk//' > pang_strains.list
  awk '{print $1}' pangenome_matrix_t0.phylip > pang_strainIDs.list

  # remove the first no_of_tax line
  tail -n +2 pang_strains.list > t && mv t pang_strains.list
  tail -n +2 pang_strainIDs.list > t && mv t pang_strainIDs.list

  paste pang_strainIDs.list pang_strains.list > pang_ID-Strain_corresp.tsv

  "${distrodir}"/add_labels2tree.pl pang_ID-Strain_corresp.tsv full_pars_tree_rooted_withBoot.ph
  
  if [ -s full_pars_tree_rooted_withBoot.ph ];
  then
      msg " >>> wrote file full_pars_tree_rooted_withBoot.ph" PROGR GREEN
  else
      msg "WARNING: could not write full_pars_tree_rooted_withBoot.ph" WARNING LRED
  fi

fi

#>>> 6. transfer bootstrap values to best -T tree
if (( runmode == 4 ))
then

  # 1. get the real parsimony tree and rename it
  ln -s "$pars_tree" full_pars_tree.ph
  
  # 2. arbitrarily root trees at first taxon labeled 0000000000 with nw_reroot
  "${bindir}"/nw_reroot full_pars_tree.ph 0000000000 > full_pars_tree_rooted.ph
  perl -pe 's/\n//; s/;/;\n/' full_pars_tree.ph > t && mv t full_parsimony_tree.ph 

  # we may already have the file all_boottrees_rooted.ph in wkdir from a previous -R 3 run
  [ ! -s all_boottrees_rooted.ph ] && "${bindir}"/nw_reroot all_boottrees.ph 0000000000 > all_boottrees_rooted.ph

  # 3. add bootstrap values to full_pars_tree_rooted.ph with nw_support
  # https://www.biostars.org/p/99308/ # Treeio And Bootstrap Values
  # https://www.biostars.org/p/95948/ # Merging Bootstrap Values And Posterior Probabilities
  # http://treethinkers.blogspot.mx/2008/10/labeling-trees-posterior-probability.html
  # http://treethinkers.blogspot.mx/2008/07/r-tip-indicating-tree-support.html
  # 
  "${bindir}"/nw_support -p full_pars_tree_rooted.ph all_boottrees_rooted.ph > full_pars_tree_rooted_withBoot.ph

  # 4. add proper lebels to full_pars_tree_rooted_withBoot.ph
  [ ! -s pangenome_matrix_t0.tab ] && ln -s ../pangenome_matrix_t0.tab .
  [ ! -s pangenome_matrix_t0.phylip ] && ln -s ../pangenome_matrix_t0.phylip .

  awk '{print $1}' pangenome_matrix_t0.tab | sed 's/\.gbk//' > pang_strains.list
  awk '{print $1}' pangenome_matrix_t0.phylip > pang_strainIDs.list

  # remove the first no_of_tax line
  tail -n +2 pang_strains.list > t && mv t pang_strains.list
  tail -n +2 pang_strainIDs.list > t && mv t pang_strainIDs.list

  paste pang_strainIDs.list pang_strains.list > pang_ID-Strain_corresp.tsv

  "${distrodir}"/add_labels2tree.pl pang_ID-Strain_corresp.tsv full_pars_tree_rooted_withBoot.ph 
  
  mv full_pars_tree_rooted_withBoot_ed.ph best_pars_tree_rooted_withBoot_ed.ph
  check_output best_pars_tree_rooted_withBoot_ed.ph
  
  mv full_pars_tree_rooted_withBoot.ph best_pars_tree_rooted_withBoot.ph 

fi

#>>> 7. Make directory cleanup
if [ -s full_pars_tree_rooted_withBoot_ed.ph ]
then
   msg "successfully created file full_parsimony_bootTree.ph" PROGR GREEN
   [ -s consense.params ] && rm consense.params 
   [ -s intrees ] && rm intree
   for d in $(find . -type d | egrep -v 'full_pars|^\.')
   do
      rm -rf "$d"
   done
fi

if [ -s best_pars_tree_rooted_withBoot_ed.ph ]
then
   msg "successfully created file full_parsimony_bootTree.ph" PROGR GREEN
   [ -s consense.params ] && rm consense.params 
   [ -s intrees ] && rm intree
   for d in $(find . -type d | grep -v '^\.')
   do
      rm -rf "$d"
   done
fi

fi # if [ "$criterion" == "PARS" ]
